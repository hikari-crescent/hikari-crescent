{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Crescent","text":"<p>Crescent is a command handler for Hikari that keeps your projects neat and tidy! It is designed from the ground up to function with application commands in a type safe manner. You won't run into silly bugs when using Crescent!  Take a look at the crescent template to see how your code will look when using Crescent.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>hikari-crescent</code> supports Python 3.9 and newer.</p> <pre><code>pip install hikari-crescent\n</code></pre>"},{"location":"#resources","title":"Resources","text":"<ul> <li> <p> Pypi</p> </li> <li> <p> Github</p> </li> <li> <p> Getting Started</p> </li> <li> <p> Guides</p> </li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Thank you to @hypergonial for help with setting up the docs.</p>"},{"location":"getting_started/","title":"Installation","text":"<p><code>hikari-crescent</code> supports Python 3.9 and newer.</p> <pre><code>pip install hikari-crescent\n</code></pre>"},{"location":"getting_started/#creating-a-bot-application","title":"Creating a Bot Application","text":"<p>Before you can start programming, you need to create a discord bot application.</p> <ul> <li> <p>Create a Bot Application</p> <ul> <li>Navigate to The Discord Application Portal, then click on the blue button that says \"New Application\".</li> </ul> <p></p> <ul> <li>Click on the \"Bot\" button.</li> </ul> <p></p> <ul> <li> <p>Click on the blue \"Add Bot\" button, and pick a memorable name!</p> <p></p> </li> </ul> <p>Finding your token (For rest bots)</p> <p>Navigate to the bot page. Press the \"Reset Token\" button to claim your token. You may need to enter a authentication code. Write this down and don't share it to anybody. It will give them access to your bot!</p> <p></p> </li> <li> <p>Invite the Bot</p> <ul> <li>Navigate to the oauth2 url generator.</li> </ul> <p></p> <ul> <li>Select the bot scope.</li> </ul> <p></p> <ul> <li>Scroll farther down to the bottom of the page. Press the copy button.</li> </ul> <p></p> <p>Paste this URL into your web browser. You will get an invite page for your bot. Add the bot to a server you are going to develop it on.</p> <p></p> </li> </ul> <p>Note</p> <p>Setting up a REST bot on the discord developer portal is very complicated, so this guide does not cover that. Please read the Discord documentation if you want to use a REST bot.</p>"},{"location":"getting_started/#basics","title":"Basics","text":"<p>Copy this code into a python file, and run with <code>python filename.py</code>.</p> GatewayREST <pre><code>import crescent\nimport hikari\n\nbot = hikari.GatewayBot(\"YOUR_TOKEN\")\nclient = crescent.Client(bot)\n\n@client.include\n@crescent.command(name=\"say\")\nclass Say:\n    word = crescent.option(str, \"The word to say\")\n\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        await ctx.respond(self.word)\n\nbot.run()\n</code></pre> <pre><code>import crescent\nimport hikari\n\nbot = hikari.RESTBot(\"YOUR_TOKEN\")\nclient = crescent.Client(bot)\n\n@client.include\n@crescent.command(name=\"say\")\nclass Say:\n    word = crescent.option(str, \"The word to say\")\n\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        await ctx.respond(self.word)\n\nbot.run()\n</code></pre>"},{"location":"getting_started/#tooling","title":"Tooling","text":"<p>It is recommended to use a typechecker when working with crescent. Both the Mypy and Pyright typecheckers are supported. The developer recommends pyright if you don't know what to pick.</p> <p>Warning</p> <p>Crescent does not throw exceptions for issues a typechecker would catch. Use a typechecker.</p>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>\ud83c\udf89 Congratulations! At this point you should have a bot. Now you should check out the guides, or if want to jump straight into coding, check out the template project for some quick examples.</p>"},{"location":"api_reference/","title":"Crescent API reference","text":"<p>Welcome to the <code>hikari-crescent</code> API documentation. If you are new to Crescent, first take a look at guides.</p>"},{"location":"api_reference/client/","title":"Client","text":""},{"location":"api_reference/client/#crescent.client.Client","title":"Client","text":"<pre><code>Client(\n    app: RESTTraits | GatewayTraits,\n    model: Any = None,\n    *,\n    tracked_guilds: Sequence[Snowflakeish] | None = None,\n    default_guild: Snowflakeish | None = None,\n    update_commands: bool = True,\n    allow_unknown_interactions: bool = False,\n    command_hooks: list[CommandHookCallbackT] | None = None,\n    command_after_hooks: list[CommandHookCallbackT]\n    | None = None,\n    event_hooks: list[EventHookCallbackT[hk_Event]]\n    | None = None,\n    event_after_hooks: list[EventHookCallbackT[hk_Event]]\n    | None = None,\n)\n</code></pre> <p>The client object is a wrapper around your bot that lets you use Crescent's features.</p>"},{"location":"api_reference/client/#crescent.client.Client--example","title":"Example","text":"<pre><code>import hikari\nimport crescent\n\nbot = hikari.GatewayBot(\"your token\")\nclient = crescent.Client(bot)\n\n# Crescent's features can be used.\n@client.include\n@crescent.command\nasync def ping(ctx: crescent.Context):\n    await ctx.respong(\"Pong\")\n\nbot.run()\n</code></pre> PARAMETER DESCRIPTION <code>app</code> <p>The hikari bot instance.</p> <p> TYPE: <code>RESTTraits | GatewayTraits</code> </p> <code>model</code> <p>An object to store global data. This object can be accessed with the <code>Plugin.model</code> property.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> <code>tracked_guilds</code> <p>The guilds to compare posted commands to. Commands will not be automatically removed from guilds that aren't in this list. This should be kept to as little guilds as possible to prevent rate limits.</p> <p> TYPE: <code>Sequence[Snowflakeish] | None</code> DEFAULT: <code>None</code> </p> <code>default_guild</code> <p>The guild to post application commands to by default. If this is None, slash commands will be posted globally.</p> <p> TYPE: <code>Snowflakeish | None</code> DEFAULT: <code>None</code> </p> <code>update_commands</code> <p>If <code>True</code> or not specified, update commands when the bot starts. Only works for gateway-based bots.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>command_hooks</code> <p>List of hooks to run before all commands.</p> <p> TYPE: <code>list[CommandHookCallbackT] | None</code> DEFAULT: <code>None</code> </p> <code>command_after_hooks</code> <p>List of hooks to run after all commands.</p> <p> TYPE: <code>list[CommandHookCallbackT] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api_reference/client/#crescent.client.Client--example","title":"Example","text":"<pre><code># In bot.py\nbot = hikari.GatewayBot(\"your token\")\nclient = crescent.Client(bot, \"I am a model\")\n\nclient.plugins.load(\"plugin\")\n\n# In plugin.py\nplugin = crescent.Plugin()\n\n@plugin.on_load\ndef on_load():\n    # Print the model object that was set earlier to the console.\n    print(plugin.model)  # prints \"I am a model\"\n</code></pre> <p>If no model is set, the model will default to <code>None</code>.</p>"},{"location":"api_reference/client/#crescent.client.Client.commands","title":"commands  <code>property</code>","text":"<pre><code>commands: CommandHandler\n</code></pre> <p>Return the command handler object. This object lets you access command information that is not normally accessible. See <code>CommandHandler</code> for more information.</p>"},{"location":"api_reference/client/#crescent.client.Client.plugins","title":"plugins  <code>property</code>","text":"<pre><code>plugins: PluginManager\n</code></pre> <p>Return the plugin manager object. This object lets you load and unload plugins. See <code>PluginManager</code> for more information.</p>"},{"location":"api_reference/client/#crescent.client.Client.include","title":"include","text":"<pre><code>include(obj: INCLUDABLE) -&gt; INCLUDABLE\n</code></pre><pre><code>include(\n    obj: None = ...,\n) -&gt; Callable[[INCLUDABLE], INCLUDABLE]\n</code></pre> <pre><code>include(\n    obj: INCLUDABLE | None = None,\n) -&gt; INCLUDABLE | Callable[[INCLUDABLE], INCLUDABLE]\n</code></pre> <p>Register an includable object, such as an event or command handler.</p>"},{"location":"api_reference/client/#crescent.client.Client.include--example","title":"Example","text":"<pre><code>client = crescent.Client(...)\n\n@client.include\n@crescent.command\nasync def ping(ctx: crescent.Context):\n    await ctx.respong(\"Pong\")\n</code></pre>"},{"location":"api_reference/client/#crescent.client.Client.on_crescent_autocomplete_error","title":"on_crescent_autocomplete_error  <code>async</code>","text":"<pre><code>on_crescent_autocomplete_error(\n    exc: Exception,\n    ctx: AutocompleteContext,\n    option: AutocompleteInteractionOption,\n    was_handled: bool,\n) -&gt; None\n</code></pre> <p>This function is run when there is an error in an autocomplete handler that is not caught with any error handlers. You can inherit from this class and override this function to change default error handling.</p>"},{"location":"api_reference/client/#crescent.client.Client.on_crescent_command_error","title":"on_crescent_command_error  <code>async</code>","text":"<pre><code>on_crescent_command_error(\n    exc: Exception, ctx: Context, was_handled: bool\n) -&gt; None\n</code></pre> <p>This function is run when there is an error in a crescent command that is not caught with any error handlers. You can inherit from this class and override this function to change default error handling.</p>"},{"location":"api_reference/client/#crescent.client.Client.on_crescent_event_error","title":"on_crescent_event_error  <code>async</code>","text":"<pre><code>on_crescent_event_error(\n    exc: Exception, event: hk_Event, was_handled: bool\n) -&gt; None\n</code></pre> <p>This function is run when there is an error in a crescent event that is not caught with any error handlers. You can inherit from this class and override this function to change default error handling.</p>"},{"location":"api_reference/client/#crescent.client.GatewayTraits","title":"GatewayTraits","text":"<p>               Bases: <code>EventManagerAware</code>, <code>RESTAware</code>, <code>Protocol</code></p> <p>The traits crescent requires for a gateway-based bot.</p>"},{"location":"api_reference/client/#crescent.client.RESTTraits","title":"RESTTraits","text":"<p>               Bases: <code>InteractionServerAware</code>, <code>RESTAware</code>, <code>Protocol</code></p> <p>The base traits crescents requires for a REST-based bot.</p>"},{"location":"api_reference/commands/","title":"Commands","text":""},{"location":"api_reference/commands/#crescent.commands.Group","title":"Group  <code>dataclass</code>","text":"<pre><code>Group(\n    name: str | LocaleBuilder,\n    description: str | LocaleBuilder | None = None,\n    hooks: list[CommandHookCallbackT] = list(),\n    after_hooks: list[CommandHookCallbackT] = list(),\n    default_member_permissions: UndefinedType\n    | int\n    | Permissions = UNDEFINED,\n    context_types: UndefinedType\n    | Iterable[ApplicationContextType] = UNDEFINED,\n)\n</code></pre> <p>A command group. A command group is a top level command that contains subcommands and <code>SubGroup</code>s.</p>"},{"location":"api_reference/commands/#crescent.commands.Group--example","title":"Example","text":"<pre><code>import crescent\n\nutils_group = crescent.Group(\"utils\")\n\n# This command will appear under the `utils` group in discord.\n@client.include\n@utils_group.child\n@crescent.command\nasync def ping(ctx: crescent.Context):\n    await ctx.respond(\"Pong\")\n</code></pre>"},{"location":"api_reference/commands/#crescent.commands.Group.after_hooks","title":"after_hooks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>after_hooks: list[CommandHookCallbackT] = field(\n    default_factory=list\n)\n</code></pre> <p>A list of hooks to run after all commands in this group.</p>"},{"location":"api_reference/commands/#crescent.commands.Group.context_types","title":"context_types  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context_types: (\n    UndefinedType | Iterable[ApplicationContextType]\n) = UNDEFINED\n</code></pre> <p>The contexts in which the command can be used.</p>"},{"location":"api_reference/commands/#crescent.commands.Group.default_member_permissions","title":"default_member_permissions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default_member_permissions: (\n    UndefinedType | int | Permissions\n) = UNDEFINED\n</code></pre> <p>The default permissions for all commands in this group.</p>"},{"location":"api_reference/commands/#crescent.commands.Group.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | LocaleBuilder | None = None\n</code></pre> <p>The description of the group. The discord API supports this feature but it does not do anything.</p>"},{"location":"api_reference/commands/#crescent.commands.Group.hooks","title":"hooks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hooks: list[CommandHookCallbackT] = field(\n    default_factory=list\n)\n</code></pre> <p>A looks of hooks to run before all commands in this group.</p>"},{"location":"api_reference/commands/#crescent.commands.Group.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str | LocaleBuilder\n</code></pre> <p>The name of the group</p>"},{"location":"api_reference/commands/#crescent.commands.Group.child","title":"child","text":"<pre><code>child(\n    includable: Includable[AppCommandMeta],\n) -&gt; Includable[AppCommandMeta]\n</code></pre> <p>Add a command to this command group.</p>"},{"location":"api_reference/commands/#crescent.commands.Group.sub_group","title":"sub_group","text":"<pre><code>sub_group(\n    name: str | LocaleBuilder,\n    description: str | LocaleBuilder | None = None,\n    hooks: list[CommandHookCallbackT] | None = None,\n    after_hooks: list[CommandHookCallbackT] | None = None,\n) -&gt; SubGroup\n</code></pre> <p>Create a sub group from this group.</p>"},{"location":"api_reference/commands/#crescent.commands.SubGroup","title":"SubGroup  <code>dataclass</code>","text":"<pre><code>SubGroup(\n    name: str | LocaleBuilder,\n    parent: Group,\n    description: str | LocaleBuilder | None = None,\n    hooks: list[CommandHookCallbackT] = list(),\n    after_hooks: list[CommandHookCallbackT] = list(),\n)\n</code></pre> <p>A command subgroup. A command subgroup is a group that is under a top level group.</p>"},{"location":"api_reference/commands/#crescent.commands.SubGroup--example","title":"Example","text":"<pre><code>import crescent\n\nutils_group = crescent.Group(\"utils\")\ntime_utils_group = utils_group.sub_group(\"time\")\n\n# This command will appear under the `utils time` group in discord.\n@client.include\n@time_utils_group.child\n@crescent.command\nasync def latency(ctx: crescent.Context):\n    await ctx.respond(f\"The latency is {bot.heartbeat_latency * 1000}ms\")\n</code></pre>"},{"location":"api_reference/commands/#crescent.commands.SubGroup.after_hooks","title":"after_hooks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>after_hooks: list[CommandHookCallbackT] = field(\n    default_factory=list\n)\n</code></pre> <p>A list of hooks to run after all commands in this group.</p>"},{"location":"api_reference/commands/#crescent.commands.SubGroup.hooks","title":"hooks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hooks: list[CommandHookCallbackT] = field(\n    default_factory=list\n)\n</code></pre> <p>A looks of hooks to run before all commands in this group.</p>"},{"location":"api_reference/commands/#crescent.commands.SubGroup.child","title":"child","text":"<pre><code>child(\n    includable: Includable[AppCommandMeta],\n) -&gt; Includable[AppCommandMeta]\n</code></pre> <p>Add a command to this command group.</p>"},{"location":"api_reference/commands/#crescent.commands.command","title":"command","text":"<pre><code>command(\n    callback: CommandCallbackT | type[ClassCommandProto],\n) -&gt; Includable[AppCommandMeta]\n</code></pre><pre><code>command(\n    *,\n    guild: Snowflakeish | None = ...,\n    name: str | LocaleBuilder | None = ...,\n    description: str | LocaleBuilder | None = ...,\n    default_member_permissions: UndefinedType\n    | int\n    | Permissions = ...,\n    context_types: UndefinedOr[\n        Iterable[ApplicationContextType]\n    ] = ...,\n    nsfw: bool | None = ...,\n) -&gt; Callable[\n    [CommandCallbackT | type[ClassCommandProto]],\n    Includable[AppCommandMeta],\n]\n</code></pre> <pre><code>command(\n    callback: CommandCallbackT\n    | type[ClassCommandProto]\n    | None = None,\n    /,\n    *,\n    guild: Snowflakeish | None = None,\n    name: str | LocaleBuilder | None = None,\n    description: str | LocaleBuilder | None = None,\n    default_member_permissions: UndefinedType\n    | int\n    | Permissions = UNDEFINED,\n    context_types: UndefinedOr[\n        Iterable[ApplicationContextType]\n    ] = UNDEFINED,\n    nsfw: bool | None = None,\n) -&gt; (\n    Includable[AppCommandMeta]\n    | Callable[\n        [CommandCallbackT | type[ClassCommandProto]],\n        Includable[AppCommandMeta],\n    ]\n)\n</code></pre> <p>Register a slash command.</p>"},{"location":"api_reference/commands/#crescent.commands.command--example","title":"Example","text":"<pre><code>import hikari\nimport crescent\n\nbot = hikari.GatewayBot(\"YOUR_TOKEN_HERE\")\nclient = crescent.Client(bot)\n\n@client.include\n@crescent.command\nasync def ping(ctx: crescent.Context):\n    await ctx.respond(\"Pong\")\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The name of this command. If not specified the function name will be used.</p> <p> TYPE: <code>str | LocaleBuilder | None</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>The description of this command. If not specified the description will be set to \"No Description\".</p> <p> TYPE: <code>str | LocaleBuilder | None</code> DEFAULT: <code>None</code> </p> <code>guild</code> <p>The guild to register this command to. If not specified this command will be registered globally.</p> <p> TYPE: <code>Snowflakeish | None</code> DEFAULT: <code>None</code> </p> <code>default_member_permissions</code> <p>The default permissions for this command. For more information see the discord api docs and the hikari docs.</p> <p> TYPE: <code>UndefinedType | int | Permissions</code> DEFAULT: <code>UNDEFINED</code> </p> <code>context_types</code> <p>The contexts in which the command can be used. Defaults to all.</p> <p> TYPE: <code>UndefinedOr[Iterable[ApplicationContextType]]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>nsfw</code> <p>Set to <code>True</code> to mark this command as nsfw. Defaults to <code>None</code>.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api_reference/commands/#crescent.commands.message_command","title":"message_command","text":"<pre><code>message_command(\n    callback: MessageCommandCallbackT,\n) -&gt; Includable[AppCommandMeta]\n</code></pre><pre><code>message_command(\n    *,\n    guild: Snowflakeish | None = ...,\n    name: str | None = ...,\n    default_member_permissions: UndefinedType\n    | int\n    | Permissions = ...,\n    context_types: UndefinedOr[\n        list[ApplicationContextType]\n    ] = ...,\n    nsfw: bool | None = ...,\n) -&gt; Callable[\n    [MessageCommandCallbackT], Includable[AppCommandMeta]\n]\n</code></pre> <pre><code>message_command(\n    callback: MessageCommandCallbackT | None = None,\n    /,\n    *,\n    guild: Snowflakeish | None = None,\n    name: str | None = None,\n    default_member_permissions: UndefinedType\n    | int\n    | Permissions = UNDEFINED,\n    context_types: UndefinedOr[\n        list[ApplicationContextType]\n    ] = UNDEFINED,\n    nsfw: bool | None = None,\n) -&gt; (\n    Callable[\n        [MessageCommandCallbackT],\n        Includable[AppCommandMeta],\n    ]\n    | Includable[AppCommandMeta]\n)\n</code></pre> <p>Register a message command. A message command can be used by right clicking on a discord message. Your bot can have up to 5 message commands.</p>"},{"location":"api_reference/commands/#crescent.commands.message_command--example","title":"Example","text":"<pre><code>import hikari\nimport crescent\n\nbot = hikari.GatewayBot(\"YOUR_TOKEN_HERE\")\nclient = crescent.Client(bot)\n\n@client.include\n@crescent.message_command\nasync def ping(ctx: crescent.Context, message: hikari.Message):\n    await ctx.respond(message.contents)\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The name of this command. If not specified the function name will be used.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>guild</code> <p>The guild to register this command to. If not specified this command will be registered globally.</p> <p> TYPE: <code>Snowflakeish | None</code> DEFAULT: <code>None</code> </p> <code>default_member_permissions</code> <p>The default permissions for this command. For more information see the discord api docs and the hikari docs.</p> <p> TYPE: <code>UndefinedType | int | Permissions</code> DEFAULT: <code>UNDEFINED</code> </p> <code>context_types</code> <p>The contexts in which the command can be used. Defaults to all.</p> <p> TYPE: <code>UndefinedOr[list[ApplicationContextType]]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>nsfw</code> <p>Set to <code>True</code> to mark this command as nsfw. Defaults to <code>None</code>.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api_reference/commands/#crescent.commands.option","title":"option","text":"<pre><code>option(\n    option_type: type[PartialChannel]\n    | Sequence[type[PartialChannel]],\n    description: str | LocaleBuilder = ...,\n    *,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[\n    InteractionChannel, InteractionChannel\n]\n</code></pre><pre><code>option(\n    option_type: type[PartialChannel]\n    | Sequence[type[PartialChannel]],\n    description: str | LocaleBuilder = ...,\n    *,\n    default: DEFAULT,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[\n    InteractionChannel | DEFAULT,\n    InteractionChannel | DEFAULT,\n]\n</code></pre><pre><code>option(\n    option_type: USER,\n    description: str | LocaleBuilder = ...,\n    *,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[User, User]\n</code></pre><pre><code>option(\n    option_type: USER,\n    description: str | LocaleBuilder = ...,\n    *,\n    default: DEFAULT,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[User | DEFAULT, User | DEFAULT]\n</code></pre><pre><code>option(\n    option_type: ROLE,\n    description: str | LocaleBuilder = ...,\n    *,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[Role, Role]\n</code></pre><pre><code>option(\n    option_type: ROLE,\n    description: str | LocaleBuilder = ...,\n    *,\n    default: DEFAULT,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[Role | DEFAULT, Role | DEFAULT]\n</code></pre><pre><code>option(\n    option_type: ATTACHMENT,\n    description: str | LocaleBuilder = ...,\n    *,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[Attachment, Attachment]\n</code></pre><pre><code>option(\n    option_type: ATTACHMENT,\n    description: str | LocaleBuilder = ...,\n    *,\n    default: DEFAULT,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[\n    Attachment | DEFAULT, Attachment | DEFAULT\n]\n</code></pre><pre><code>option(\n    option_type: type[Mentionable],\n    description: str | LocaleBuilder = ...,\n    *,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[Mentionable, Mentionable]\n</code></pre><pre><code>option(\n    option_type: type[Mentionable],\n    description: str | LocaleBuilder = ...,\n    *,\n    default: DEFAULT,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[\n    Mentionable | DEFAULT, Mentionable | DEFAULT\n]\n</code></pre><pre><code>option(\n    option_type: type[bool],\n    description: str | LocaleBuilder = ...,\n    *,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[bool, bool]\n</code></pre><pre><code>option(\n    option_type: type[bool],\n    description: str | LocaleBuilder = ...,\n    *,\n    default: DEFAULT,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[bool | DEFAULT, bool | DEFAULT]\n</code></pre><pre><code>option(\n    option_type: type[int],\n    description: str | LocaleBuilder = ...,\n    *,\n    choices: Sequence[tuple[str | LocaleBuilder, int]]\n    | None = ...,\n    autocomplete: AutocompleteCallbackT[int] | None = ...,\n    min_value: int | None = ...,\n    max_value: int | None = ...,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[int, int]\n</code></pre><pre><code>option(\n    option_type: type[int],\n    description: str | LocaleBuilder = ...,\n    *,\n    default: DEFAULT,\n    choices: Sequence[tuple[str | LocaleBuilder, int]]\n    | None = ...,\n    autocomplete: AutocompleteCallbackT[int] | None = ...,\n    min_value: int | None = ...,\n    max_value: int | None = ...,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[int | DEFAULT, int | DEFAULT]\n</code></pre><pre><code>option(\n    option_type: type[float],\n    description: str | LocaleBuilder = ...,\n    *,\n    choices: Sequence[tuple[str | LocaleBuilder, float]]\n    | None = ...,\n    autocomplete: AutocompleteCallbackT[float] | None = ...,\n    min_value: float | None = ...,\n    max_value: float | None = ...,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[float, float]\n</code></pre><pre><code>option(\n    option_type: type[float],\n    description: str | LocaleBuilder = ...,\n    *,\n    default: DEFAULT,\n    choices: Sequence[tuple[str | LocaleBuilder, float]]\n    | None = ...,\n    autocomplete: AutocompleteCallbackT[float] | None = ...,\n    min_value: float | None = ...,\n    max_value: float | None = ...,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[float | DEFAULT, float | DEFAULT]\n</code></pre><pre><code>option(\n    option_type: type[str],\n    description: str | LocaleBuilder = ...,\n    *,\n    min_length: int | None = ...,\n    max_length: int | None = ...,\n    choices: Sequence[tuple[str | LocaleBuilder, str]]\n    | None = ...,\n    autocomplete: AutocompleteCallbackT[str] | None = ...,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[str, str]\n</code></pre><pre><code>option(\n    option_type: type[str],\n    description: str | LocaleBuilder = ...,\n    *,\n    default: DEFAULT,\n    min_length: int | None = ...,\n    max_length: int | None = ...,\n    choices: Sequence[tuple[str | LocaleBuilder, str]]\n    | None = ...,\n    autocomplete: AutocompleteCallbackT[str] | None = ...,\n    name: str | LocaleBuilder | None = ...,\n) -&gt; ClassCommandOption[str | DEFAULT, int | DEFAULT]\n</code></pre> <pre><code>option(\n    option_type: type[OptionTypesT]\n    | Sequence[type[PartialChannel]],\n    description: str | LocaleBuilder = \"No Description\",\n    *,\n    name: str | LocaleBuilder | None = None,\n    default: UndefinedOr[Any] = UNDEFINED,\n    choices: Sequence[\n        tuple[str | LocaleBuilder, str | int | float]\n    ]\n    | None = None,\n    min_value: int | float | None = None,\n    max_value: int | float | None = None,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    autocomplete: AutocompleteCallbackT[Any] | None = None,\n) -&gt; ClassCommandOption[Any, Any]\n</code></pre> <p>An option when declaring a command using class syntax.</p>"},{"location":"api_reference/commands/#crescent.commands.option--example","title":"Example","text":"<pre><code>@client.include\n@crescent.command(name=\"say\")\nclass Say:\n    word = crescent.option(str)\n\n    async def callback(self, ctx: crescent.Context):\n        await ctx.respond(self.word)\n</code></pre> PARAMETER DESCRIPTION <code>description</code> <p>The description for this option. Defaults to \"No Description\".</p> <p> TYPE: <code>str | LocaleBuilder</code> DEFAULT: <code>'No Description'</code> </p> <code>name</code> <p>The name to use for this option. By default, the name of the property on the option the option is set to will be used for the name. In the above example the name would be <code>word</code>.</p> <p> TYPE: <code>str | LocaleBuilder | None</code> DEFAULT: <code>None</code> </p> <code>default</code> <p>The default value for this option. Specifying this will make this option optional.</p> <p> TYPE: <code>UndefinedOr[Any]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>choices</code> <p>A set of choices a user can pick from for this option. Only available for <code>int</code>, <code>str</code>, and <code>float</code> option types.</p> <p> TYPE: <code>Sequence[tuple[str | LocaleBuilder, str | int | float]] | None</code> DEFAULT: <code>None</code> </p> <code>min_value</code> <p>The minimum value for a number the user inputs. Only available for <code>int</code> and <code>float</code> option types.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>None</code> </p> <code>man_value</code> <p>The maximum value for a number the user inputs. Only available for <code>int</code> and <code>float</code> option types.</p> <p> </p> <code>min_length</code> <p>The minimum length for a <code>str</code> that the user inputs.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>max_length</code> <p>The maximum length for a <code>str</code> that the user inputs.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>autocomplete</code> <p>An autocomplete callback for this option.</p> <p> TYPE: <code>AutocompleteCallbackT[Any] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api_reference/commands/#crescent.commands.option--example","title":"Example","text":"<pre><code>async def autocomplete_response(\n    ctx: crescent.AutocompleteContext, option: hikari.AutocompleteInteractionOption\n) -&gt; list[tuple[str, str]]:\n    # Return a list of tuples of (option name, option value)\n    return [(\"Some Option\", \"1234\")]\n\n@client.include\n@crescent.command\nclass autocomplete:\n    result = crescent.option(str, \"Respond to the message\", autocomplete=autocomplete_response)\n\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        await ctx.respond(self.result, ephemeral=True)\n</code></pre>"},{"location":"api_reference/commands/#crescent.commands.user_command","title":"user_command","text":"<pre><code>user_command(\n    callback: UserCommandCallbackT,\n) -&gt; Includable[AppCommandMeta]\n</code></pre><pre><code>user_command(\n    *,\n    guild: Snowflakeish | None = ...,\n    name: str | None = ...,\n    default_member_permissions: UndefinedType\n    | int\n    | Permissions = ...,\n    context_types: UndefinedOr[\n        list[ApplicationContextType]\n    ] = ...,\n    nsfw: bool | None = ...,\n) -&gt; Callable[\n    [UserCommandCallbackT], Includable[AppCommandMeta]\n]\n</code></pre> <pre><code>user_command(\n    callback: UserCommandCallbackT | None = None,\n    /,\n    *,\n    guild: Snowflakeish | None = None,\n    name: str | None = None,\n    default_member_permissions: UndefinedType\n    | int\n    | Permissions = UNDEFINED,\n    context_types: UndefinedOr[\n        list[ApplicationContextType]\n    ] = UNDEFINED,\n    nsfw: bool | None = None,\n) -&gt; (\n    Callable[\n        [UserCommandCallbackT], Includable[AppCommandMeta]\n    ]\n    | Includable[AppCommandMeta]\n)\n</code></pre> <p>Register a user command. A user command can be used by right clicking on a discord user. Your bot can have up to 5 user commands.</p>"},{"location":"api_reference/commands/#crescent.commands.user_command--example","title":"Example","text":"<pre><code>import hikari\nimport crescent\n\nbot = hikari.GatewayBot(\"YOUR_TOKEN_HERE\")\nclient = crescent.Client(bot)\n\n@client.include\n@crescent.user_command\nasync def ping(ctx: crescent.Context, user: hikari.User):\n    await ctx.respond(user.username)\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p>The name of this command. If not specified the function name will be used.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>guild</code> <p>The guild to register this command to. If not specified this command will be registered globally.</p> <p> TYPE: <code>Snowflakeish | None</code> DEFAULT: <code>None</code> </p> <code>default_member_permissions</code> <p>The default permissions for this command. For more information see the discord api docs and the hikari docs.</p> <p> TYPE: <code>UndefinedType | int | Permissions</code> DEFAULT: <code>UNDEFINED</code> </p> <code>context_types</code> <p>The contexts in which the command can be used. Defaults to all.</p> <p> TYPE: <code>UndefinedOr[list[ApplicationContextType]]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>nsfw</code> <p>Set to <code>True</code> to mark this command as nsfw. Defaults to <code>None</code>.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api_reference/context/","title":"Context","text":""},{"location":"api_reference/context/#crescent.context.AutocompleteContext","title":"AutocompleteContext  <code>dataclass</code>","text":"<pre><code>AutocompleteContext(\n    interaction: PartialInteraction,\n    app: GatewayTraits | RESTTraits,\n    client: Client,\n    application_id: Snowflake,\n    type: int,\n    token: str,\n    id: Snowflake,\n    version: int,\n    channel_id: Snowflake,\n    guild_id: Snowflake | None,\n    registered_guild_id: Snowflake | None,\n    user: User,\n    member: Member | None,\n    entitlements: Sequence[hikari.Entitlement],\n    locale: Locale,\n    command: str,\n    command_type: hikari.CommandType,\n    group: str | None,\n    sub_group: str | None,\n    options: dict[str, Any],\n    _has_created_response: bool,\n    _has_deferred_response: bool,\n    _rest_interaction_future: Future[\n        InteractionResponseBuilder\n    ]\n    | None,\n)\n</code></pre> <p>               Bases: <code>InteractionContext</code></p> <p>Represents the context for autocomplete interactions</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app: GatewayTraits | RESTTraits\n</code></pre> <p>The application instance.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.application_id","title":"application_id  <code>instance-attribute</code>","text":"<pre><code>application_id: Snowflake\n</code></pre> <p>The ID for the client that this interaction belongs to.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.channel_id","title":"channel_id  <code>instance-attribute</code>","text":"<pre><code>channel_id: Snowflake\n</code></pre> <p>The channel ID of the channel that the interaction was used in.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.client","title":"client  <code>instance-attribute</code>","text":"<pre><code>client: Client\n</code></pre> <p>The crescent Client instance.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: str\n</code></pre> <p>The name of the command.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.entitlements","title":"entitlements  <code>instance-attribute</code>","text":"<pre><code>entitlements: Sequence[hikari.Entitlement]\n</code></pre> <p>For monetized apps, any entitlements involving this user. Represents access to SKUs.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.guild_id","title":"guild_id  <code>instance-attribute</code>","text":"<pre><code>guild_id: Snowflake | None\n</code></pre> <p>The guild ID of the guild that this interaction was used in.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: Snowflake\n</code></pre> <p>The ID of the interaction.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.interaction","title":"interaction  <code>instance-attribute</code>","text":"<pre><code>interaction: AutocompleteInteraction\n</code></pre> <p>The interaction object.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.member","title":"member  <code>instance-attribute</code>","text":"<pre><code>member: Member | None\n</code></pre> <p>The member object for the user that triggered this interaction, if used in a guild.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.options","title":"options  <code>instance-attribute</code>","text":"<pre><code>options: dict[str, Any]\n</code></pre> <p>The options that were provided by the user.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.registered_guild_id","title":"registered_guild_id  <code>instance-attribute</code>","text":"<pre><code>registered_guild_id: Snowflake | None\n</code></pre> <p>The guild ID of the guild that this command is registered to.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.token","title":"token  <code>instance-attribute</code>","text":"<pre><code>token: str\n</code></pre> <p>The token for the interaction.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: int\n</code></pre> <p>The type of the interaction.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.user","title":"user  <code>instance-attribute</code>","text":"<pre><code>user: User\n</code></pre> <p>The user who triggered this command interaction.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: int\n</code></pre> <p>Version of the interaction system this interaction is under.</p>"},{"location":"api_reference/context/#crescent.context.AutocompleteContext.into","title":"into","text":"<pre><code>into(context_t: Type[ContextT]) -&gt; ContextT\n</code></pre> <p>Convert to a context of a different type.</p>"},{"location":"api_reference/context/#crescent.context.Context","title":"Context  <code>dataclass</code>","text":"<pre><code>Context(\n    interaction: PartialInteraction,\n    app: GatewayTraits | RESTTraits,\n    client: Client,\n    application_id: Snowflake,\n    type: int,\n    token: str,\n    id: Snowflake,\n    version: int,\n    channel_id: Snowflake,\n    guild_id: Snowflake | None,\n    registered_guild_id: Snowflake | None,\n    user: User,\n    member: Member | None,\n    entitlements: Sequence[hikari.Entitlement],\n    locale: Locale,\n    command: str,\n    command_type: hikari.CommandType,\n    group: str | None,\n    sub_group: str | None,\n    options: dict[str, Any],\n    _has_created_response: bool,\n    _has_deferred_response: bool,\n    _rest_interaction_future: Future[\n        InteractionResponseBuilder\n    ]\n    | None,\n)\n</code></pre> <p>               Bases: <code>InteractionContext</code></p> <p>Represents the context for command interactions</p>"},{"location":"api_reference/context/#crescent.context.Context.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app: GatewayTraits | RESTTraits\n</code></pre> <p>The application instance.</p>"},{"location":"api_reference/context/#crescent.context.Context.application_id","title":"application_id  <code>instance-attribute</code>","text":"<pre><code>application_id: Snowflake\n</code></pre> <p>The ID for the client that this interaction belongs to.</p>"},{"location":"api_reference/context/#crescent.context.Context.channel","title":"channel  <code>property</code>","text":"<pre><code>channel: PermissibleGuildChannel | GuildThreadChannel | None\n</code></pre> <p>Get this context's guild channel or thread from the cache.</p> <p>\ud83d\udcdd This will always be <code>None</code> for interactions triggered in a DM channel.</p>"},{"location":"api_reference/context/#crescent.context.Context.channel_id","title":"channel_id  <code>instance-attribute</code>","text":"<pre><code>channel_id: Snowflake\n</code></pre> <p>The channel ID of the channel that the interaction was used in.</p>"},{"location":"api_reference/context/#crescent.context.Context.client","title":"client  <code>instance-attribute</code>","text":"<pre><code>client: Client\n</code></pre> <p>The crescent Client instance.</p>"},{"location":"api_reference/context/#crescent.context.Context.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: str\n</code></pre> <p>The name of the command.</p>"},{"location":"api_reference/context/#crescent.context.Context.entitlements","title":"entitlements  <code>instance-attribute</code>","text":"<pre><code>entitlements: Sequence[hikari.Entitlement]\n</code></pre> <p>For monetized apps, any entitlements involving this user. Represents access to SKUs.</p>"},{"location":"api_reference/context/#crescent.context.Context.guild","title":"guild  <code>property</code>","text":"<pre><code>guild: GatewayGuild | None\n</code></pre> <p>Get this context's guild from the cache.</p>"},{"location":"api_reference/context/#crescent.context.Context.guild_id","title":"guild_id  <code>instance-attribute</code>","text":"<pre><code>guild_id: Snowflake | None\n</code></pre> <p>The guild ID of the guild that this interaction was used in.</p>"},{"location":"api_reference/context/#crescent.context.Context.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: Snowflake\n</code></pre> <p>The ID of the interaction.</p>"},{"location":"api_reference/context/#crescent.context.Context.interaction","title":"interaction  <code>instance-attribute</code>","text":"<pre><code>interaction: CommandInteraction\n</code></pre> <p>The interaction object.</p>"},{"location":"api_reference/context/#crescent.context.Context.member","title":"member  <code>instance-attribute</code>","text":"<pre><code>member: Member | None\n</code></pre> <p>The member object for the user that triggered this interaction, if used in a guild.</p>"},{"location":"api_reference/context/#crescent.context.Context.options","title":"options  <code>instance-attribute</code>","text":"<pre><code>options: dict[str, Any]\n</code></pre> <p>The options that were provided by the user.</p>"},{"location":"api_reference/context/#crescent.context.Context.registered_guild_id","title":"registered_guild_id  <code>instance-attribute</code>","text":"<pre><code>registered_guild_id: Snowflake | None\n</code></pre> <p>The guild ID of the guild that this command is registered to.</p>"},{"location":"api_reference/context/#crescent.context.Context.token","title":"token  <code>instance-attribute</code>","text":"<pre><code>token: str\n</code></pre> <p>The token for the interaction.</p>"},{"location":"api_reference/context/#crescent.context.Context.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: int\n</code></pre> <p>The type of the interaction.</p>"},{"location":"api_reference/context/#crescent.context.Context.user","title":"user  <code>instance-attribute</code>","text":"<pre><code>user: User\n</code></pre> <p>The user who triggered this command interaction.</p>"},{"location":"api_reference/context/#crescent.context.Context.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: int\n</code></pre> <p>Version of the interaction system this interaction is under.</p>"},{"location":"api_reference/context/#crescent.context.Context.defer","title":"defer  <code>async</code>","text":"<pre><code>defer(ephemeral: bool = False) -&gt; None\n</code></pre> <p>Defer this interaction response, allowing you to respond within the next 15 minutes.</p>"},{"location":"api_reference/context/#crescent.context.Context.delete","title":"delete  <code>async</code>","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete the previous response to this interaction.</p>"},{"location":"api_reference/context/#crescent.context.Context.delete--example","title":"Example","text":"<pre><code>import asyncio\n\n@client.include\n@crescent.command\nasync def command(ctx: crescent.Context):\n    await ctx.respond(\"im going to disappear\")\n    await asyncio.sleep(3)\n    await ctx.delete()\n</code></pre>"},{"location":"api_reference/context/#crescent.context.Context.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(\n    content: UndefinedNoneOr[Any] = UNDEFINED,\n    *,\n    attachment: UndefinedNoneOr[\n        Resourceish | Attachment\n    ] = UNDEFINED,\n    attachments: UndefinedNoneOr[\n        Sequence[Resourceish | Attachment]\n    ] = UNDEFINED,\n    component: UndefinedNoneOr[\n        ComponentBuilder\n    ] = UNDEFINED,\n    components: UndefinedNoneOr[\n        Sequence[ComponentBuilder]\n    ] = UNDEFINED,\n    embed: UndefinedNoneOr[Embed] = UNDEFINED,\n    embeds: UndefinedNoneOr[Sequence[Embed]] = UNDEFINED,\n    mentions_everyone: UndefinedOr[bool] = UNDEFINED,\n    user_mentions: UndefinedOr[\n        SnowflakeishSequence[PartialUser] | bool\n    ] = UNDEFINED,\n    role_mentions: UndefinedOr[\n        SnowflakeishSequence[PartialRole] | bool\n    ] = UNDEFINED,\n) -&gt; Message\n</code></pre> <p>Edit the previous response to this interaction.</p>"},{"location":"api_reference/context/#crescent.context.Context.edit--example","title":"Example","text":"<pre><code>import asyncio\n\n@client.include\n@crescent.command\nasync def command(ctx: crescent.Context):\n    await ctx.respond(\"hello there\")\n    await asyncio.sleep(3)\n    await ctx.edit(\"general kenobi\")\n</code></pre> <p>\ud83d\udcdd Message flags are ignored in followup responses.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to send.</p> <p> TYPE: <code>UndefinedNoneOr[Any]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>attachment</code> <p>A single attachment to send.</p> <p> TYPE: <code>UndefinedNoneOr[Resourceish | Attachment]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>attachments</code> <p>A list of attachments to send.</p> <p> TYPE: <code>UndefinedNoneOr[Sequence[Resourceish | Attachment]]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>component</code> <p>A single component to send.</p> <p> TYPE: <code>UndefinedNoneOr[ComponentBuilder]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>components</code> <p>A list of components to send.</p> <p> TYPE: <code>UndefinedNoneOr[Sequence[ComponentBuilder]]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>embed</code> <p>A single embed to send.</p> <p> TYPE: <code>UndefinedNoneOr[Embed]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>embeds</code> <p>A list of embeds to send.</p> <p> TYPE: <code>UndefinedNoneOr[Sequence[Embed]]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>mentions_everyone</code> <p>Allow <code>@everyone</code> and <code>@here</code> to ping users if set to <code>True</code>.</p> <p> TYPE: <code>UndefinedOr[bool]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>user_mentions</code> <p>If <code>True</code>, all mentioned users will be sent a notification. If a list of users is provided, only those users will be mentioned.</p> <p> TYPE: <code>UndefinedOr[SnowflakeishSequence[PartialUser] | bool]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>role_mentions</code> <p>If <code>True</code>, all mentioned roles will be sent a notification. If a list of roles is provided, only those roles will be mentioned.</p> <p> TYPE: <code>UndefinedOr[SnowflakeishSequence[PartialRole] | bool]</code> DEFAULT: <code>UNDEFINED</code> </p>"},{"location":"api_reference/context/#crescent.context.Context.into","title":"into","text":"<pre><code>into(context_t: Type[ContextT]) -&gt; ContextT\n</code></pre> <p>Convert to a context of a different type.</p>"},{"location":"api_reference/context/#crescent.context.Context.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(\n    content: UndefinedOr[Any] = UNDEFINED,\n    *,\n    ensure_message: Literal[True],\n    ephemeral: bool = False,\n    flags: int | MessageFlag | UndefinedType = UNDEFINED,\n    tts: UndefinedOr[bool] = UNDEFINED,\n    attachment: UndefinedOr[Resourceish] = UNDEFINED,\n    attachments: UndefinedOr[\n        Sequence[Resourceish]\n    ] = UNDEFINED,\n    component: UndefinedOr[ComponentBuilder] = UNDEFINED,\n    components: UndefinedOr[\n        Sequence[ComponentBuilder]\n    ] = UNDEFINED,\n    embed: UndefinedOr[Embed] = UNDEFINED,\n    embeds: UndefinedOr[Sequence[Embed]] = UNDEFINED,\n    mentions_everyone: UndefinedOr[bool] = UNDEFINED,\n    user_mentions: UndefinedOr[\n        SnowflakeishSequence[PartialUser] | bool\n    ] = UNDEFINED,\n    role_mentions: UndefinedOr[\n        SnowflakeishSequence[PartialRole] | bool\n    ] = UNDEFINED,\n) -&gt; Message\n</code></pre><pre><code>respond(\n    content: UndefinedOr[Any] = UNDEFINED,\n    *,\n    ephemeral: bool = False,\n    flags: int | MessageFlag | UndefinedType = UNDEFINED,\n    tts: UndefinedOr[bool] = UNDEFINED,\n    attachment: UndefinedOr[Resourceish] = UNDEFINED,\n    attachments: UndefinedOr[\n        Sequence[Resourceish]\n    ] = UNDEFINED,\n    component: UndefinedOr[ComponentBuilder] = UNDEFINED,\n    components: UndefinedOr[\n        Sequence[ComponentBuilder]\n    ] = UNDEFINED,\n    embed: UndefinedOr[Embed] = UNDEFINED,\n    embeds: UndefinedOr[Sequence[Embed]] = UNDEFINED,\n    mentions_everyone: UndefinedOr[bool] = UNDEFINED,\n    user_mentions: UndefinedOr[\n        SnowflakeishSequence[PartialUser] | bool\n    ] = UNDEFINED,\n    role_mentions: UndefinedOr[\n        SnowflakeishSequence[PartialRole] | bool\n    ] = UNDEFINED,\n    ensure_message: Literal[False] = ...,\n) -&gt; Message | None\n</code></pre> <pre><code>respond(\n    content: UndefinedOr[Any] = UNDEFINED,\n    *,\n    ephemeral: bool = False,\n    flags: int | MessageFlag | UndefinedType = UNDEFINED,\n    tts: UndefinedOr[bool] = UNDEFINED,\n    attachment: UndefinedOr[Resourceish] = UNDEFINED,\n    attachments: UndefinedOr[\n        Sequence[Resourceish]\n    ] = UNDEFINED,\n    component: UndefinedOr[ComponentBuilder] = UNDEFINED,\n    components: UndefinedOr[\n        Sequence[ComponentBuilder]\n    ] = UNDEFINED,\n    embed: UndefinedOr[Embed] = UNDEFINED,\n    embeds: UndefinedOr[Sequence[Embed]] = UNDEFINED,\n    mentions_everyone: UndefinedOr[bool] = UNDEFINED,\n    user_mentions: UndefinedOr[\n        SnowflakeishSequence[PartialUser] | bool\n    ] = UNDEFINED,\n    role_mentions: UndefinedOr[\n        SnowflakeishSequence[PartialRole] | bool\n    ] = UNDEFINED,\n    ensure_message: bool = False,\n) -&gt; Message | None\n</code></pre> <p>Respond to an interaction. This function can be used multiple times for one interaction,</p>"},{"location":"api_reference/context/#crescent.context.Context.respond--example","title":"Example","text":"<pre><code>@client.include\n@crescent.command\nasync def command(ctx: crescent.Context):\n    # Initial response\n    await ctx.respond(\"hello\")\n    # After the first response, a followup response will be sent.\n    await ctx.respond(\"word\")\n</code></pre> <p>\ud83d\udcdd Message flags are ignored in followup responses.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to send.</p> <p> TYPE: <code>UndefinedOr[Any]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>ephemeral</code> <p>Send this message as ephemeral if set to true. Ephemeral messages can be dismissed by the user, similar to Clyde messages. This kwarg only affects the initial response to an interaction.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>flags</code> <p>Message flags to send with the message. You do not need to use this, and exists for compatibility in the future. Instead set the <code>ephemeral</code> kwarg  to <code>True</code>.</p> <p> TYPE: <code>int | MessageFlag | UndefinedType</code> DEFAULT: <code>UNDEFINED</code> </p> <code>tts</code> <p>If true, send a text to speech message.</p> <p> TYPE: <code>UndefinedOr[bool]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>attachment</code> <p>A single attachment to send.</p> <p> TYPE: <code>UndefinedOr[Resourceish]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>attachments</code> <p>A list of attachments to send.</p> <p> TYPE: <code>UndefinedOr[Sequence[Resourceish]]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>component</code> <p>A single component to send.</p> <p> TYPE: <code>UndefinedOr[ComponentBuilder]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>components</code> <p>A list of components to send.</p> <p> TYPE: <code>UndefinedOr[Sequence[ComponentBuilder]]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>embed</code> <p>A single embed to send.</p> <p> TYPE: <code>UndefinedOr[Embed]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>embeds</code> <p>A list of embeds to send.</p> <p> TYPE: <code>UndefinedOr[Sequence[Embed]]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>mentions_everyone</code> <p>Allow <code>@everyone</code> and <code>@here</code> to ping users if set to <code>True</code>.</p> <p> TYPE: <code>UndefinedOr[bool]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>user_mentions</code> <p>If <code>True</code>, all mentioned users will be sent a notification. If a list of users is provided, only those users will be mentioned.</p> <p> TYPE: <code>UndefinedOr[SnowflakeishSequence[PartialUser] | bool]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>role_mentions</code> <p>If <code>True</code>, all mentioned roles will be sent a notification. If a list of roles is provided, only those roles will be mentioned.</p> <p> TYPE: <code>UndefinedOr[SnowflakeishSequence[PartialRole] | bool]</code> DEFAULT: <code>UNDEFINED</code> </p> <code>ensure_message</code> <p>A message is not returned the first time you use <code>Context.respond</code>. Set <code>ensure_message=True</code> to automatically fetch a message and return it.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api_reference/context/#crescent.context.Context.respond_with_builder","title":"respond_with_builder  <code>async</code>","text":"<pre><code>respond_with_builder(\n    builder: ResponseBuilderT, ensure_message: bool = False\n) -&gt; Message | None\n</code></pre> <p>Respond to an interaction with a builder.</p> PARAMETER DESCRIPTION <code>builder</code> <p>The builder to respond with.</p> <p> TYPE: <code>ResponseBuilderT</code> </p> <code>ensure_message</code> <p>If an InteractionMessageBuilder is passed, this will fetch the message and return it. Otherwise does nothing.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RAISES DESCRIPTION <code>InteractionAlreadyAcknowledgedError</code> <p>Raised when calling this method after responding to an interaction.</p> RETURNS DESCRIPTION <code>Message | None</code> <p>The message if <code>ensure_message</code> is <code>True</code> and a message builder was passed.</p>"},{"location":"api_reference/context/#crescent.context.Context.respond_with_modal","title":"respond_with_modal  <code>async</code>","text":"<pre><code>respond_with_modal(\n    title: str,\n    custom_id: str,\n    components: Sequence[ComponentBuilder],\n) -&gt; None\n</code></pre> <p>Respond to an interaction with a modal.</p> PARAMETER DESCRIPTION <code>title</code> <p>The title of the modal.</p> <p> TYPE: <code>str</code> </p> <code>custom_id</code> <p>The custom id of the modal.</p> <p> TYPE: <code>str</code> </p> <code>components</code> <p>The components to add to the modal.</p> <p> TYPE: <code>Sequence[ComponentBuilder]</code> </p> RAISES DESCRIPTION <code>InteractionAlreadyAcknowledgedError</code> <p>Raised when calling this method after responding to an interaction.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext","title":"InteractionContext  <code>dataclass</code>","text":"<pre><code>InteractionContext(\n    interaction: PartialInteraction,\n    app: GatewayTraits | RESTTraits,\n    client: Client,\n    application_id: Snowflake,\n    type: int,\n    token: str,\n    id: Snowflake,\n    version: int,\n    channel_id: Snowflake,\n    guild_id: Snowflake | None,\n    registered_guild_id: Snowflake | None,\n    user: User,\n    member: Member | None,\n    entitlements: Sequence[hikari.Entitlement],\n    locale: Locale,\n    command: str,\n    command_type: hikari.CommandType,\n    group: str | None,\n    sub_group: str | None,\n    options: dict[str, Any],\n    _has_created_response: bool,\n    _has_deferred_response: bool,\n    _rest_interaction_future: Future[\n        InteractionResponseBuilder\n    ]\n    | None,\n)\n</code></pre> <p>Represents the context for interactions</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app: GatewayTraits | RESTTraits\n</code></pre> <p>The application instance.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.application_id","title":"application_id  <code>instance-attribute</code>","text":"<pre><code>application_id: Snowflake\n</code></pre> <p>The ID for the client that this interaction belongs to.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.channel_id","title":"channel_id  <code>instance-attribute</code>","text":"<pre><code>channel_id: Snowflake\n</code></pre> <p>The channel ID of the channel that the interaction was used in.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.client","title":"client  <code>instance-attribute</code>","text":"<pre><code>client: Client\n</code></pre> <p>The crescent Client instance.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: str\n</code></pre> <p>The name of the command.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.entitlements","title":"entitlements  <code>instance-attribute</code>","text":"<pre><code>entitlements: Sequence[hikari.Entitlement]\n</code></pre> <p>For monetized apps, any entitlements involving this user. Represents access to SKUs.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.guild_id","title":"guild_id  <code>instance-attribute</code>","text":"<pre><code>guild_id: Snowflake | None\n</code></pre> <p>The guild ID of the guild that this interaction was used in.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: Snowflake\n</code></pre> <p>The ID of the interaction.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.interaction","title":"interaction  <code>instance-attribute</code>","text":"<pre><code>interaction: PartialInteraction\n</code></pre> <p>The interaction object.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.member","title":"member  <code>instance-attribute</code>","text":"<pre><code>member: Member | None\n</code></pre> <p>The member object for the user that triggered this interaction, if used in a guild.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.options","title":"options  <code>instance-attribute</code>","text":"<pre><code>options: dict[str, Any]\n</code></pre> <p>The options that were provided by the user.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.registered_guild_id","title":"registered_guild_id  <code>instance-attribute</code>","text":"<pre><code>registered_guild_id: Snowflake | None\n</code></pre> <p>The guild ID of the guild that this command is registered to.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.token","title":"token  <code>instance-attribute</code>","text":"<pre><code>token: str\n</code></pre> <p>The token for the interaction.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: int\n</code></pre> <p>The type of the interaction.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.user","title":"user  <code>instance-attribute</code>","text":"<pre><code>user: User\n</code></pre> <p>The user who triggered this command interaction.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: int\n</code></pre> <p>Version of the interaction system this interaction is under.</p>"},{"location":"api_reference/context/#crescent.context.InteractionContext.into","title":"into","text":"<pre><code>into(context_t: Type[ContextT]) -&gt; ContextT\n</code></pre> <p>Convert to a context of a different type.</p>"},{"location":"api_reference/errors/","title":"Errors","text":""},{"location":"api_reference/errors/#crescent.errors.catch_autocomplete","title":"catch_autocomplete","text":"<pre><code>catch_autocomplete(\n    *exceptions: type[Exception],\n) -&gt; Callable[\n    [AutocompleteErrorHandlerCallbackT[Any]],\n    Includable[AutocompleteErrorHandlerCallbackT[Any]],\n]\n</code></pre> <p>Catch an exception or subclasses of an exception passed into this function when the exception is raised in an autocomplete handler.</p>"},{"location":"api_reference/errors/#crescent.errors.catch_autocomplete--example","title":"Example","text":"<pre><code>@client.include\n@crescent.catch_autocomplete(Exception)\nasync def on_autocomplete_random_error(\n    exc: Exception,\n    ctx: crescent.AutocompleteContext,\n    inter: hikari.AutocompleteInteractionOption,\n) -&gt; None:\n    print(f\"{exc} raised in autocomplete for {ctx.command}!\")\n\n# An autocomplete callback that a command is using.\nasync def example_autocomplete(\n    ctx: crescent.AutocompleteContext, option: hikari.AutocompleteInteractionOption\n) -&gt; list[tuple[str, str]]:\n    raise Exception\n</code></pre>"},{"location":"api_reference/errors/#crescent.errors.catch_command","title":"catch_command","text":"<pre><code>catch_command(\n    *exceptions: type[Exception],\n) -&gt; Callable[\n    [CommandErrorHandlerCallbackT[Any]],\n    Includable[CommandErrorHandlerCallbackT[Any]],\n]\n</code></pre> <p>Catch an exception or subclasses of an exception passed into this function when the exception is raised in a command.</p>"},{"location":"api_reference/errors/#crescent.errors.catch_command--example","title":"Example","text":"<pre><code>@client.include\n@crescent.catch_command(Exception)\nasync def handler(exc: Exception, ctx: crescent.Context) -&gt; None:\n    await ctx.respond(f\"{exc} raised in {ctx.command}!\")\n\n@client.include\n@crescent.command\nasync def example_command(ctx: crescent.Context):\n    ...\n</code></pre>"},{"location":"api_reference/errors/#crescent.errors.catch_event","title":"catch_event","text":"<pre><code>catch_event(\n    *exceptions: type[Exception],\n) -&gt; Callable[\n    [EventErrorHandlerCallbackT[Any]],\n    Includable[EventErrorHandlerCallbackT[Any]],\n]\n</code></pre> <p>Catch an exception or subclasses of an exception passed into this function when the exception is raised in an event.</p>"},{"location":"api_reference/errors/#crescent.errors.catch_event--example","title":"Example","text":"<pre><code>@client.include\n@crescent.catch_event(Exception)\nasync def handler(exc: Exception, event: hikari.Event) -&gt; None:\n    print(f\"{exc} raised in {event}!\")\n\n@client.include\n@crescent.event\nasync def example_error(event: hikari.MessageCreateEvent) -&gt; None:\n    raise Exception\n</code></pre>"},{"location":"api_reference/events/","title":"Events","text":""},{"location":"api_reference/events/#crescent.events.event","title":"event","text":"<pre><code>event(\n    callback: CallbackT[EventT],\n) -&gt; Includable[EventMeta[EventT]]\n</code></pre><pre><code>event(\n    *, event_type: type[EventT] | None\n) -&gt; Callable[\n    [CallbackT[EventT]], Includable[EventMeta[EventT]]\n]\n</code></pre> <pre><code>event(\n    callback: CallbackT[EventT] | None = None,\n    /,\n    *,\n    event_type: type[EventT] | None = None,\n) -&gt; (\n    Callable[\n        [CallbackT[EventT]], Includable[EventMeta[EventT]]\n    ]\n    | Includable[EventMeta[EventT]]\n)\n</code></pre> <p>Listen to an event. This function should be used instead of <code>hikari.GatewayBot.listen</code> whenever possible.</p>"},{"location":"api_reference/events/#crescent.events.event--example","title":"Example","text":"<pre><code>import crescent\n\nclient = crescent.Client(...)\n\n# Listen to the message create event\n@client.include\n@crescent.event\nasync def ping(event: hikari.MessageCreateEvent):\n    ...\n</code></pre> <p>Event types can be provided using the <code>event_type</code> kwarg if you do not want to use type annotations.</p>"},{"location":"api_reference/exceptions/","title":"Exceptions","text":""},{"location":"api_reference/exceptions/#crescent.exceptions.AlreadyRegisteredError","title":"AlreadyRegisteredError","text":"<p>               Bases: <code>CrescentException</code></p> <p>Command or exception catch function was already registered</p>"},{"location":"api_reference/exceptions/#crescent.exceptions.ConverterExceptionMeta","title":"ConverterExceptionMeta  <code>dataclass</code>","text":"<pre><code>ConverterExceptionMeta(\n    command: type[ClassCommandProto],\n    option_key: str,\n    value: Any,\n    exception: Exception,\n)\n</code></pre>"},{"location":"api_reference/exceptions/#crescent.exceptions.ConverterExceptionMeta.option_key","title":"option_key  <code>instance-attribute</code>","text":"<pre><code>option_key: str\n</code></pre> <p>The key of the option on the command class</p>"},{"location":"api_reference/exceptions/#crescent.exceptions.ConverterExceptionMeta.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Any\n</code></pre> <p>The unconverted value</p>"},{"location":"api_reference/exceptions/#crescent.exceptions.ConverterExceptions","title":"ConverterExceptions","text":"<pre><code>ConverterExceptions(errors: list[ConverterExceptionMeta])\n</code></pre> <p>               Bases: <code>CrescentException</code></p> <p>One or more errors occurred while running the converters for a command.</p>"},{"location":"api_reference/exceptions/#crescent.exceptions.CrescentException","title":"CrescentException","text":"<p>               Bases: <code>Exception</code></p> <p>Base Exception for all exceptions Crescent throws</p>"},{"location":"api_reference/exceptions/#crescent.exceptions.InteractionAlreadyAcknowledgedError","title":"InteractionAlreadyAcknowledgedError","text":"<p>               Bases: <code>CrescentException</code></p> <p>Raise when an interaction is already acknowledged</p>"},{"location":"api_reference/exceptions/#crescent.exceptions.PermissionsError","title":"PermissionsError","text":"<p>               Bases: <code>CrescentException</code></p> <p>Raise when a permission is declared in a subcommand</p>"},{"location":"api_reference/exceptions/#crescent.exceptions.PluginAlreadyLoadedError","title":"PluginAlreadyLoadedError","text":"<p>               Bases: <code>CrescentException</code></p> <p>A plugin is attempted to be loaded but the plugin manager already loaded the plugin.</p>"},{"location":"api_reference/locale/","title":"Locale","text":""},{"location":"api_reference/locale/#crescent.locale.LocaleBuilder","title":"LocaleBuilder","text":"<p>               Bases: <code>ABC</code></p> <p>A class that can be inherited from to created APIs to use locales in your code.</p>"},{"location":"api_reference/locale/#crescent.locale.LocaleBuilder.fallback","title":"fallback  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>fallback: str\n</code></pre> <p>Return the name used when there is no localization for a language.</p>"},{"location":"api_reference/locale/#crescent.locale.LocaleBuilder.build","title":"build  <code>abstractmethod</code>","text":"<pre><code>build() -&gt; Mapping[str, str]\n</code></pre> <p>Builds the locales for a command. Returns a <code>Mapping</code> of language codes to strings.</p> <p>Discord API Docs Localization.</p>"},{"location":"api_reference/mentionable/","title":"Mentionable","text":""},{"location":"api_reference/mentionable/#crescent.mentionable.Mentionable","title":"Mentionable  <code>dataclass</code>","text":"<pre><code>Mentionable(user: User | None, role: Role | None)\n</code></pre> <p>Represent's discord's mentionable type. A mentionable can be a User or Role. Not that it can not be both.</p>"},{"location":"api_reference/mentionable/#crescent.mentionable.Mentionable--example","title":"Example","text":"<pre><code>@client.include\n@crescent.command\nasync def command(ctx: crescent.Context, mentionable: crescent.Mentionable):\n    if mentionable.is_user:\n        user = mentionable.unwrap_user()\n    else:\n        role = mentionable.unwrap_role()\n</code></pre>"},{"location":"api_reference/plugin/","title":"Plugin","text":""},{"location":"api_reference/plugin/#crescent.plugin.Plugin","title":"Plugin","text":"<pre><code>Plugin(\n    *,\n    command_hooks: list[CommandHookCallbackT] | None = None,\n    command_after_hooks: list[CommandHookCallbackT]\n    | None = None,\n    event_hooks: list[EventHookCallbackT[Event]]\n    | None = None,\n    event_after_hooks: list[EventHookCallbackT[Event]]\n    | None = None,\n)\n</code></pre> <p>               Bases: <code>Generic[BotT, ModelT]</code></p> <p>A plugin object to be used in a plugin file.</p>"},{"location":"api_reference/plugin/#crescent.plugin.Plugin--example","title":"Example","text":"<pre><code>import hikari\nimport crescent\n\nplugin = crescent.Plugin[hikari.GatewayBot, None]()\n</code></pre> <p>You can load this file with <code>PluginManager.load</code></p>"},{"location":"api_reference/plugin/#crescent.plugin.PluginManager","title":"PluginManager","text":"<pre><code>PluginManager(client: Client)\n</code></pre> <p>A class that allows you to load and unload plugins. You should not construct this class yourself. It will be provided to you as the <code>clients.plugins</code> property when you construct a <code>Client</code> object.</p>"},{"location":"api_reference/plugin/#crescent.plugin.PluginManager.load","title":"load","text":"<pre><code>load(\n    path: str, /, *, refresh: bool = ...\n) -&gt; Plugin[Any, Any]\n</code></pre><pre><code>load(\n    path: str, *, strict: Literal[True], refresh: bool = ...\n) -&gt; Plugin[Any, Any]\n</code></pre><pre><code>load(\n    path: str,\n    *,\n    strict: Literal[False],\n    refresh: bool = ...,\n) -&gt; Plugin[Any, Any] | None\n</code></pre><pre><code>load(\n    path: str, refresh: bool = ..., strict: bool = ...\n) -&gt; Plugin[Any, Any] | None\n</code></pre> <pre><code>load(\n    path: str, refresh: bool = False, strict: bool = True\n) -&gt; Plugin[Any, Any] | None\n</code></pre> <p>Load a plugin from the module path.</p> <pre><code>import crescent\n\nbot = crescent.Bot(token=...)\n\nbot.plugins.load(\"folder.plugin\")\n</code></pre> PARAMETER DESCRIPTION <code>path</code> <p>The module path for the plugin.</p> <p> TYPE: <code>str</code> </p> <code>refresh</code> <p>Whether or not to reload the plugin and the plugin's module.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strict</code> <p>If false, the function will not error when module file does not have a plugin variable.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"api_reference/plugin/#crescent.plugin.PluginManager.load_folder","title":"load_folder","text":"<pre><code>load_folder(\n    path: str, refresh: bool = False, strict: bool = True\n) -&gt; list[Plugin[Any, Any]]\n</code></pre> <p>Loads plugins from a folder.</p> <pre><code>import crescent\nimport hikari\n\nbot = hikari.GatewayBot(token=...)\nclient = crescent.Client(bot)\n\nclient.plugins.load(\"project.plugin_folder\")\n</code></pre> <p>If a file is attempted to be loaded that does not have a plugin variable, a <code>ValueError</code> will be raised. Files who's names start with an underscore will not be loaded.</p> PARAMETER DESCRIPTION <code>path</code> <p>The path to the folder that contains the plugins.</p> <p> TYPE: <code>str</code> </p> <code>refresh</code> <p>Whether or not to reload the plugin and the plugin's module.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strict</code> <p>If false, the function will not error when a file does not have a plugin variable.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <p>Returns:     A list of plugins that were loaded.</p>"},{"location":"api_reference/plugin/#crescent.plugin.PluginManager.unload","title":"unload","text":"<pre><code>unload(path: str) -&gt; None\n</code></pre> <p>Unload a plugin.</p> PARAMETER DESCRIPTION <code>path</code> <p>The module path for the plugin.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api_reference/plugin/#crescent.plugin.PluginManager.unload_all","title":"unload_all","text":"<pre><code>unload_all() -&gt; None\n</code></pre> <p>Unload all of the plugins that are currently loaded.</p>"},{"location":"api_reference/typedefs/","title":"Typedefs","text":""},{"location":"api_reference/typedefs/#crescent.typedefs.ClassCommandProto","title":"ClassCommandProto","text":"<p>               Bases: <code>Protocol</code></p> <p>A type with all the attributes required for class commands.</p>"},{"location":"api_reference/ext/cooldowns/","title":"Cooldowns","text":""},{"location":"api_reference/ext/cooldowns/#cooldowns.cooldown","title":"cooldown","text":"<pre><code>cooldown(\n    capacity: int,\n    period: timedelta,\n    *,\n    callback: CooldownCallbackT = _default_callback,\n    bucket: BucketCallbackT = _default_bucket,\n) -&gt; Callable[[Context], Awaitable[HookResult | None]]\n</code></pre> <p>Ratelimit implementation using a sliding window.</p> PARAMETER DESCRIPTION <code>capacity</code> <p>The amount of times the command can be used within the period.</p> <p> TYPE: <code>int</code> </p> <code>period</code> <p>The period of time, in seconds, between cooldown resets.</p> <p> TYPE: <code>timedelta</code> </p> <code>callback</code> <p>Callback for when a user is ratelimited.</p> <p> TYPE: <code>CooldownCallbackT</code> DEFAULT: <code>_default_callback</code> </p> <code>bucket</code> <p>Callback that returns a key for a bucket.</p> <p> TYPE: <code>BucketCallbackT</code> DEFAULT: <code>_default_bucket</code> </p>"},{"location":"api_reference/ext/locales/","title":"Locales","text":""},{"location":"api_reference/ext/locales/#locales.LocaleMap","title":"LocaleMap  <code>dataclass</code>","text":"<pre><code>LocaleMap(\n    _fallback: str,\n    da: str | None = None,\n    de: str | None = None,\n    en_GB: str | None = None,\n    en_US: str | None = None,\n    es_ES: str | None = None,\n    fr: str | None = None,\n    hr: str | None = None,\n    it: str | None = None,\n    lt: str | None = None,\n    hu: str | None = None,\n    nl: str | None = None,\n    no: str | None = None,\n    pl: str | None = None,\n    pt_BR: str | None = None,\n    ro: str | None = None,\n    fi: str | None = None,\n    sv_SE: str | None = None,\n    vi: str | None = None,\n    tr: str | None = None,\n    cs: str | None = None,\n    el: str | None = None,\n    bg: str | None = None,\n    ru: str | None = None,\n    uk: str | None = None,\n    hi: str | None = None,\n    th: str | None = None,\n    zh_CN: str | None = None,\n    ja: str | None = None,\n    zh_TW: str | None = None,\n    ko: str | None = None,\n)\n</code></pre> <p>               Bases: <code>LocaleBuilder</code></p> <p>An implementation of <code>crescent.LocaleBuilder</code> that allows you to declare locales as kwargs.</p> <pre><code>import crescent\nfrom crescent.ext import locales\n\n@bot.include\n@crescent.command(name=locales.LocaleMap(\"fallback\", en_US=\"english-name\", fr=\"french-name\"))\nasync def command(ctx: crescent.Context):\n    ...\n</code></pre>"},{"location":"api_reference/ext/locales/#locales.LocaleMap.fallback","title":"fallback  <code>property</code>","text":"<pre><code>fallback: str\n</code></pre> <p>Return the name used when there is no localization for a language.</p>"},{"location":"api_reference/ext/locales/#locales.LocaleMap.build","title":"build","text":"<pre><code>build() -&gt; dict[str, str]\n</code></pre> <p>Builds the locales for a command. Returns a <code>Mapping</code> of language codes to strings.</p> <p>Discord API Docs Localization.</p>"},{"location":"api_reference/ext/locales/#locales.i18n","title":"i18n","text":"<pre><code>i18n(fallback: str)\n</code></pre> <p>               Bases: <code>LocaleBuilder</code></p> <p>An implementation of <code>crescent.LocaleBuilder</code> that uses <code>python-i18n</code>.</p> <p>\u26a0\ufe0f Translations must be loaded before any commands.</p> <pre><code>import crescent\nimport i18n\nfrom crescent.ext import locales\n\ni18n.add_translation(\"name\", \"translated-name\", locale=\"en\")\n\n@bot.include\n@crescent.command(name=locales.i18n(\"name\"))\nasync def command(ctx: crescent.Context):\n    ...\n</code></pre>"},{"location":"api_reference/ext/locales/#locales.i18n.fallback","title":"fallback  <code>property</code>","text":"<pre><code>fallback: str\n</code></pre> <p>Return the name used when there is no localization for a language.</p>"},{"location":"api_reference/ext/locales/#locales.i18n.build","title":"build","text":"<pre><code>build() -&gt; dict[str, str]\n</code></pre> <p>Builds the locales for a command. Returns a <code>Mapping</code> of language codes to strings.</p> <p>Discord API Docs Localization.</p>"},{"location":"api_reference/ext/tasks/","title":"Tasks","text":""},{"location":"api_reference/ext/tasks/#tasks.cron.cronjob","title":"cronjob","text":"<pre><code>cronjob(\n    cron: str, /, on_startup: bool = False\n) -&gt; Callable[[TaskCallbackT], Includable[Cronjob]]\n</code></pre> <p>Run a task at the time specified by the cron schedule expression.</p> PARAMETER DESCRIPTION <code>cron</code> <p>The cronjob used to schedule when the callback is run. <code>croniter</code> is used for parsing cron expressions.</p> <p> TYPE: <code>str</code> </p> <code>on_startup</code> <p>If <code>True</code>, run the callback when this task is started.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api_reference/ext/tasks/#tasks.loop.Loop","title":"Loop","text":"<pre><code>Loop(callback: TaskCallbackT, delay_seconds: float)\n</code></pre> <p>               Bases: <code>Task</code></p>"},{"location":"api_reference/ext/tasks/#tasks.loop.Loop.set_interval","title":"set_interval","text":"<pre><code>set_interval(\n    *,\n    hours: int = ...,\n    minutes: int = ...,\n    seconds: int = ...,\n) -&gt; None\n</code></pre><pre><code>set_interval(timedelta: _timedelta) -&gt; None\n</code></pre> <pre><code>set_interval(\n    timedelta: _timedelta | None = None,\n    *,\n    hours: int = 0,\n    minutes: int = 0,\n    seconds: int = 0,\n) -&gt; None\n</code></pre> <p>Cancel the currently scheduled task and schedule the next task and future tasks with a new wait time.</p>"},{"location":"api_reference/ext/tasks/#tasks.loop.Loop.set_interval--example","title":"Example","text":"<pre><code>from datetime import datetime\nimport crescent\nfrom crescent.ext import tasks\n\nbot = hikari.GatewayBot(\"...\")\nclient = crescent.Client(bot)\n\n@client.include\n@tasks.loop(seconds=1)\nasync def my_task():\n    print(datetime.now())\n\n@client.include\n@crescent.command\nasync def set_interval(ctx: crescent.Context, interval: int):\n    print(f\"setting new interval to {interval}\")\n    my_task.metadata.set_interval(seconds=interval)\n    await ctx.respond(f\"Set new interval to {interval}s\")\n</code></pre>"},{"location":"api_reference/ext/tasks/#tasks.loop.loop","title":"loop","text":"<pre><code>loop(\n    *,\n    hours: int = ...,\n    minutes: int = ...,\n    seconds: int = ...,\n) -&gt; retT\n</code></pre><pre><code>loop(timedelta: _timedelta) -&gt; retT\n</code></pre> <pre><code>loop(\n    timedelta: _timedelta | None = None,\n    *,\n    hours: int = 0,\n    minutes: int = 0,\n    seconds: int = 0,\n) -&gt; retT\n</code></pre> <p>Run a callback when the bot is started and every time the specified time interval has passed.</p>"},{"location":"api_reference/ext/tasks/#tasks.task.Task","title":"Task","text":"<pre><code>Task(callback: TaskCallbackT)\n</code></pre> <p>               Bases: <code>ABC</code></p>"},{"location":"guides/","title":"Guides","text":"<p>Heres a bunch of guides for things you'll find useful! Please make a Github issue if you find any errors.</p> <ul> <li> <p>/  Commands</p> <p>The fundamentals for creating slash commands with crescent, and everything past the fundamentals.</p> </li> <li> <p> Plugins</p> <p>Plugins are used to split your bot into multiple files.</p> </li> <li> <p> Events</p> <p>Guides on how to to subscribe to events sent to your bot by Discord.</p> </li> <li> <p> Hooks</p> <p>Hooks are a powerful tool allowing you to run code before an after a command. Hooks can be used for command setup and cleanup code.</p> </li> <li> <p> Error Handling</p> <p>Crescent provides powerful tools for error handling, giving you control even when things go wrong.</p> </li> <li> <p> Cooldowns</p> <p>Command rate-limiting tools built into Crescent. These tools allow you to give commands a cooldown for when they can be used.</p> </li> <li> <p> Tasks</p> <p>Tools to loop functions on a specific time interval. Tasks automatically start and stop when the bot starts and stops.</p> </li> <li> <p> Locales</p> <p>Locales are used to localize your bot for different languages.</p> </li> </ul>"},{"location":"guides/commands/","title":"Commands","text":"<p>Before you can create a command, you need to create a bot.</p> GatewayREST <pre><code>import crescent\nimport hikari\n\nbot = hikari.GatewayBot(\"YOUR_TOKEN\")\nclient = crescent.Client(bot)\n\n# `bot.run()` starts the bot.\n# Any code after this line will not be run until the bot is closed. \nbot.run()\n</code></pre> <pre><code>import crescent\nimport hikari\n\nbot = hikari.RESTBot(\"YOUR_TOKEN\")\nclient = crescent.Client(bot)\n\n# `bot.run()` starts the bot.\n# Any code after this line will not be run until the bot is closed. \nbot.run()\n</code></pre> <p>Warning</p> <p>Storing your token in your source code is a bad idea. Store your TOKEN in a <code>.env</code> file.</p> <p>The first command we will make is the ping command.</p> GatewayREST <pre><code>bot = hikari.GatewayBot(\"YOUR_TOKEN\")\nclient = crescent.Client(bot)\n\n# Commands can be defined after you create the client variable\n# and before `bot.run()`\n\n@client.include\n@crescent.command(name=\"ping\", description=\"Ping the bot.\")\nclass PingCommand:\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        await ctx.respond(\"Pong!\")\n\nbot.run()\n</code></pre> <pre><code>bot = hikari.RESTBot(\"YOUR_TOKEN\")\nclient = crescent.Client(bot)\n\n# Commands can be defined after you create the client variable\n# and before `bot.run()`\n\n@client.include\n@crescent.command(name=\"ping\", description=\"Ping the bot.\")\nclass PingCommand:\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        await ctx.respond(\"Pong!\")\n\nbot.run()\n</code></pre> <p>\u26a0\ufe0f Commands must call <code>await ctx.respond()</code> within 3 seconds or call <code>await ctx.defer()</code> to get 15 minutes to respond.</p> <p>So what's going on here? <code>@crescent.command</code> turns your class into a command object. <code>@bot.include</code> adds the command to your bot. Many objects in Crescent can be added to your bot with <code>@bot.include</code>, these are called Includables and we will go over them in more detail later.</p> <p>If you are new to Python, you may not have seen <code>ctx: crescent.Context</code> before. This is called a type hint. It tells the reader what type <code>ctx</code> is, and your IDE can use type hints to provide better autocomplete. Although they are not required, it is recommended to use type hints whenever you can.</p> <pre><code>#      The name of the argument   The return type\n#                 \\/                    \\/\ndef my_function(argument: SomeType) -&gt; None:\n#                           /\\\n#                The type of the argument\n#\n# The argument name and argument type\n# are separated with a colon.\n</code></pre>"},{"location":"guides/commands/#adding-options","title":"Adding Options","text":"<p>Options are added by adding class-attrs to the class.</p> <pre><code>@client.include\n@crescent.command(name=\"say\")\nclass SayCommand:\n# The name of the command option\n#    \\/\n    word = crescent.option(str)\n#                           /\\\n# The type of the command option\n\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        # options are accessed attributes on the class\n        await ctx.respond(self.word)\n</code></pre> <p>Crescent's option syntax is type safe. This means that commands will seamlessly work with typecheckers like mypy and pyright. (You don't need to worry about this if you are new to Python!)</p> <p>Class commands can be cumbersome for small commands. Crescent provides function commands for those cases.</p> <pre><code>@client.include\n@crescent.command\nasync def ping(ctx: crescent.Context):\n    await ctx.respond(\"Pong!\")\n</code></pre> <p>It is recommended to use function commands when your command does not have any options.</p>"},{"location":"guides/commands/#user-and-message-commands","title":"User and Message commands","text":"<p>So far only slash commands have been covered. There is two more types of application commands: user context menu and message context menu commands. You can use these by right clicking on a user or message respectively.</p> <p>Both user and message commands are only supported as functions.</p> <pre><code>@bot.include\n@crescent.user_command\nasync def user_command(ctx: crescent.Context, user: hikari.User):\n    ...\n\n\n@bot.include\n@crescent.message_command\nasync def message_command(ctx: crescent.Context, message: hikari.Message):\n    ...\n</code></pre>"},{"location":"guides/commands/#command-options","title":"Command Options","text":"<p>This is what a command with an option called <code>name</code> looks like in the Discord client..</p> <p></p> <p>Options can also have a custom description and name. If no description is provided, the description will default to \"No Description\". This example shows an option amed \"option\" with the description \"your custom description\". The secondoption, <code>option2</code>, has the name \"custom-name\" and description \"also your custom description\".</p> <pre><code>@client.include\n@crescent.command\nclass MyCommand:\n    option = crescent.option(str, \"your custom description\")\n    option2 = crescent.option(str, name=\"custom-name\", description=\"also your custom description\")\n\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        ...\n\n    # The `...` is a placeholder that means that your code\n    # should go there instead.\n</code></pre>"},{"location":"guides/commands/#option-types","title":"Option Types","text":"<p>Crescent provides these option types. You can find more information on option types here (You can ignore <code>SUBCOMMAND</code> and <code>SUBCOMMAND_GROUP</code> for now.) This might look a bit daunting, but we will go into detail on what each option type is in this section.</p> Type Option Type <code>str</code> Text <code>int</code> Integer <code>bool</code> Boolean <code>float</code> Number <code>hikari.User</code> User <code>hikari.Role</code> Role <code>crescent.Mentionable</code> Role or User <code>hikari.PartialChannel</code> Channel. The options will be the channel type and its subclasses. <code>list</code>[<code>hikari.PartialChannel</code>] Channel. ^ <code>hikari.Attachment</code> Attachment"},{"location":"guides/commands/#making-parameters-optional","title":"Making Parameters Optional","text":"<p>Options will be optional if a default value is provided. This example shows an option with the default value <code>None</code>.</p> <pre><code>@client.include\n@crescent.command(name=\"command\")\nclass MyCommand:\n    optional_option = crescent.option(str, default=None)\n\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        ...\n</code></pre>"},{"location":"guides/commands/#more-information-on-types","title":"More Information on Types","text":"<p>Strings, Ints, Floats, and Booleans all use python's built in types.</p> <p>Note</p> <p>If you are comfortable reading function overloads you can look at the source code.</p> <pre><code>@client.include\n@crescent.command(name=\"command\")\nclass MyCommand:\n    word = crescent.option(str)\n    integer = crescent.option(int)\n    number = crescent.option(float)\n    boolean = crescent.option(bool)\n\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        # You can now do something with the options.\n        await ctx.respond(\n            f\"{self.word}\\n{self.integer}\\n{self.number}\\n{self.boolean}\"\n        )\n</code></pre> <p>These types use a hikari object.</p> <pre><code>import hikari\n\n@client.include\n@crescent.command(name=\"command\")\nclass MyCommand:\n    user = crescent.option(hikari.User)\n    role = crescent.option(hikari.Role)\n    attachment = crescent.option(hikari.Attachment)\n\n    # The channel type will be restricted depending on what\n    # channel object you choose. In this example only channels\n    # that users can type in can be chosen.\n    channel = crescent.option(hikari.TextableChannel)\n\n    # This option can only be voice channels.\n    voice_channel = crescent.option(hikari.GuildVoiceChannel)\n\n\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        ...\n</code></pre> <p>The final option type is mentionable, which allows a user to choose a user or role.</p> <pre><code>import hikari\n\n@client.include\n@crescent.command(name=\"command\")\nclass MyCommand:\n    mentionable = crescent.option(crescent.Mentionable)\n\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        if self.mentionable.user:\n            # This is a user. `mentionable.role` will be `None`.\n            await ctx.respond(\"You picked a user!\")\n        if self.mentionable.role:\n            # This is a role. `mentionable.user` will be `None`.\n            await ctx.respond(\"You picked a role!\")\n</code></pre>"},{"location":"guides/commands/#autocomplete","title":"Autocomplete","text":"<p>Autocomplete is a way for your command to suggest values for an option. The <code>autocomplete=</code> kwarg can be used for <code>int</code>, <code>float</code>, and <code>str</code> types.</p> <pre><code>async def autocomplete_response(\n    ctx: crescent.AutocompleteContext, option: hikari.AutocompleteInteractionOption\n) -&gt; Sequence[tuple[str | int | float, str]]:\n    return [(\"Some Option\", \"1234\")]\n\n@client.include\n@crescent.command\nclass class_example:\n    result = crescent.option(str, \"Respond to the message\", autocomplete=autocomplete_response)\n\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        await ctx.respond(self.result, ephemeral=True)\n</code></pre> <p>Options can also be accessed inside the callback. The <code>ctx.options</code> dictionary contains snowflakes or values for all the options a user has already filled out. The <code>ctx.fetch_values</code> function converts the snowflakes in this dictionary to the correct type and returns it. If you bot object is <code>hikari.impl.CacheAware</code> these values are fetched from the cache. Otherwise, they need to be fetched from a REST endpoint.</p> <pre><code>async def fetch_autocomplete_options(\n    ctx: crescent.AutocompleteContext, option: hikari.AutocompleteInteractionOption\n) -&gt; Sequence[tuple[str, str]]:\n    # An option dict where discord objects are all snowflakes.\n    options = ctx.options\n\n    # Return options with snowflakes converted into the option types.\n    options = await ctx.fetch_options()\n\n    # Return no options.\n    return []\n\nbot.run()\n</code></pre>"},{"location":"guides/commands/#converters","title":"Converters","text":"<p>Converters allow you to easily have command options converted into custom values. Converters can be sync or async functions. They must accept a single argument of the type that the option is, and return the converted value or raise an error.</p> <pre><code>def to_number(value: str) -&gt; int:\n    return int(value)\n\n@client.include\n@crescent.command\nclass converter_example:\n    value = crescent.option(str, \"Actually a number\").convert(to_number)\n\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        reveal_type(self.value)  # int\n</code></pre> <p>Once all converters have finished running, any exceptions will be combined into a single <code>ConverterExceptions</code>, which can be caught by using the <code>catch_command</code> decorator (see the error handling guide).</p>"},{"location":"guides/commands/#command-groups","title":"Command Groups","text":"<p>Commands can be grouped or grouped into groups of groups. In Crescent these groups are called <code>groups</code> and <code>sub_groups</code>.</p> <pre><code>import crescent\n\n# Create a group\ngroup = crescent.Group(\"outer-group\")\n# Create a sub group\nsub_group = group.sub_group(\"inner-group\")\n</code></pre> <p>To add a command to a group simply do:</p> <pre><code>@client.include\n@group.child\n@crescent.command\nasync def group_command(ctx: crescent.Context):\n    ...\n\n@client.include\n@sub_group.child\n@crescent.command\nasync def sub_group_command(ctx: crescent.Context):\n    ...\n</code></pre> <p>Do not combine the <code>group</code> and <code>sub_group</code> decorators. This will cause a command to be registered multiple times.</p> <p>You can not create a group with the same name as a command.</p> <pre><code>help_group = crescent.Group(\"help\")\n\n@client.include\n@help_group.child\n@crescent.command\nasync def say(ctx: crescent.Context):\n    ...\n\n# This command will cause the bot to crash\n@client.include\n@crescent.command\nasync def help(ctx: crescent.Context):\n    ...\n</code></pre>"},{"location":"guides/error_handling/","title":"Error Handling","text":"<p>The only thing exceptional is your code never throwing exceptions. Crescent provides error handling features for commands, events, and autocomplete to solve this problem.</p> <p>Error handles can be registered for a specific exception. Creating a custom exception type for when things are supposed to go wrong gives you a lot of control over your program.</p> <p>This error will be handled with the <code>@crescent.catch_command</code> decorator. This function takes an exception and <code>crescent.Context</code> as an argument. All subclasses of the exception will be caught.</p> <pre><code># Creating a new error class gives more control over what errors are handled.\nclass MyError(Exception):\n  ...\n\n@client.include\n@crescent.command\nasync def my_command(ctx: crescent.Context, number: int):\n  # Lets raise an error if the number wasn't positive.\n  if number &lt; 0:\n    raise MyError\n  await ctx.reply(str(number))\n\n\n# Handle the error\n@client.include\n@crescent.catch_command(MyError)\n# The name of this function does not matter.\nasync def on_cmd_my_error(exc: MyError, ctx: crescent.Context) -&gt; None:\n    await ctx.respond(f\"{exc} raised in {ctx.command}!\")\n</code></pre> <p>Event and autocomplete error handling works similar to command error handling.</p> <pre><code>@client.include\n@crescent.catch_event(MyError)\nasync def on_event_random_error(exc: MyError, event: hikari.Event) -&gt; None:\n    # In this example, we don't respond to the event if something went wrong.\n    print(f\"{exc} raised in {event}!\")\n\n@client.include\n@crescent.catch_autocomplete(MyError)\nasync def on_autocomplete_random_error(\n    exc: MyError,\n    ctx: crescent.AutocompleteContext,\n    inter: hikari.AutocompleteInteractionOption,\n) -&gt; None:\n    print(f\"{exc} raised in autocomplete for {ctx.command}!\")\n</code></pre> <p>Note that error handling can catch errors from other plugins. If you want to catch an error specific to a plugin the best method to do this is creating a new exception type, only referenced in that plugin.</p>"},{"location":"guides/error_handling/#handling-all-exceptions","title":"Handling All Exceptions","text":"<p>A global error handler can be created by catch <code>Exception</code>.</p> <pre><code>@client.include\n@crescent.catch_command(Exception)\nasync def global_error_handler(exc: Exception, ctx: crescent.Context):\n    await ctx.respond(\"handled\")\n</code></pre> <p>The same method can be used with event error handlers and autocomplete error handlers.</p>"},{"location":"guides/events/","title":"Events","text":"<p>Events are the main driving force behind Gateway bots. Whenever \"something\" happens on Discord that your bot should be notified of, Discord will send an event.</p> <p>Although hikari provides <code>hikari.GatewayBot.subscribe</code> you should NOT use this function. Crescent's method of subscribing to events will work in plugins and will allow you to take advantage of error handling.</p> <p>The <code>@crescent.event</code> decorator is used to subscribe to an event. The type hint for <code>event</code> is the event type from hikari you want to subscribe to. This must be a subtype of <code>hikari.Event</code>.</p> <pre><code>import hikari\n\n@client.include\n@crescent.event\nasync def on_message_create(event: hikari.MessageCreateEvent):\n    if event.message.author.is_bot:\n        return\n    await event.message.respond(\"Hello!\")\n</code></pre>"},{"location":"guides/hooks/","title":"Hooks","text":"<p>Hooks allow you to run code before or after a command is run or an event is processed. They also allow you to create checks for a certain command.</p> <p>This is a simple command hook that says \"hello there\" before every command you hook it to.</p> <pre><code>async def my_hook(ctx: crescent.Context) -&gt; None:\n    await ctx.respond(\"Hello there\")\n</code></pre> <p>To use this hook on a command, simply do: <pre><code>@client.include\n@crescent.hook(my_hook)\n@crescent.command\nasync def my_command(ctx: crescent.Context) -&gt; None:\n    await ctx.respond(\"General Kenobi\")\n</code></pre></p> <p>This command will respond \"Hello there\" and \"General kenobi\" in two different messages.</p> <p>You can access command options in hooks with <code>ctx.options</code>. This is a dict of option name to option value.</p>"},{"location":"guides/hooks/#using-hooks-as-checks","title":"Using hooks as checks","text":"<p>You can also stop a command callback from running in a hook. Simply return <code>crescent.HookResult(exit=True)</code></p> <p>This is a command that uses that feature. It stops you from using the command if your name has an \"L\" in it.</p> <pre><code>async def no_Ls_allowed(ctx: crescent.Context) -&gt; crescent.HookResult:\n    if \"l\" in ctx.user.username.lower():\n        await ctx.respond(\"You can't use this command!\")\n        return crescent.HookResult(exit=True)\n\n    return crescent.HookResult()\n\n@client.include\n@crescent.hook(no_Ls_allowed)\n@crescent.command\nasync def my_command(ctx: crescent.Context) -&gt; None:\n    await ctx.respond(\"Hello\")\n</code></pre>"},{"location":"guides/hooks/#running-a-hook-after-a-command","title":"Running a hook after a command","text":"<p>To run a hook after a command, add <code>after=True</code> to the decorator. This command will return \"General Kenobi\" then \"Hello there\" in two separate messages. <pre><code>async def my_hook(ctx: crescent.Context) -&gt; None:\n    await ctx.respond(\"Hello there\")\n</code></pre></p> <p>To use this hook on a command, simply do: <pre><code>@client.include\n@crescent.hook(my_hook, after=True)\n@crescent.command\nasync def my_command(ctx: crescent.Context) -&gt; None:\n    await ctx.respond(\"General Kenobi\")\n</code></pre></p>"},{"location":"guides/hooks/#adding-hooks-to-more-than-commands","title":"Adding hooks to more than commands","text":"<p>Bots and plugins (we will cover these later) support hooks by adding them with the <code>command_hooks</code> and <code>command_after_hooks</code> kwargs. Hooks on the bot object will run for all commands. Hooks on the plugin object will run for all commands in that plugin.</p> <pre><code>bot = crescent.Bot(\"...\", command_hooks=[hook_a, hook_b])\n</code></pre> <p><code>crescent.Group</code> and <code>crescent.SubGroup</code> also support hooks. Use the <code>hooks</code> and <code>after_hooks</code> kwargs to add them. Groups and sub groups will add hooks to any commands in their respective groups.</p> <pre><code>group = crescent.Group(\"group\", hooks=[hook_a])\nsub_group = group.sub_group(\"sub-group\", hooks=[hook_b])\n</code></pre> <p>Sub groups will inherit all hooks from the group.</p>"},{"location":"guides/hooks/#hook-resolution-order","title":"Hook Resolution Order","text":"<p><code>Command -&gt; Sub Group -&gt; Group -&gt; Plugin -&gt; Bot</code></p>"},{"location":"guides/hooks/#using-hooks-for-ratelimiting","title":"Using hooks for ratelimiting","text":"<p>One of crescent's built in extensions is <code>crescent.ext.cooldowns</code>, allowing for rate limiting. To use this extension, you must install <code>hikari-crescent[cooldowns]</code>.</p> <pre><code>import crescent\nimport datetime\nfrom crescent.ext import cooldowns\n\nbucket_size = 1\ndelay = datetime.timedelta(seconds=20)\n\n@client.include\n@crescent.hook(cooldowns.cooldown(bucket_size, delay))\n@crescent.command\nasync def my_command(ctx: crescent.Context) -&gt; None:\n    await ctx.respond(\"General Kenobi\")\n</code></pre> <p>To see more information on this function, check the API reference for <code>crescent.ext.cooldowns</code>.</p>"},{"location":"guides/hooks/#event-hooks","title":"Event Hooks","text":"<p>Hooks can be used for events. An event callback can use any hook for the event type or supertype of the event type in the callback.</p> <pre><code>async def human_only(event: hikari.MessageCreateEvent) -&gt; crescent.HookResult:\n    if not event.is_human:\n        return crescent.HookResult(exit=True)\n    return crescent.HookResult()\n\n\n@client.include\n@crescent.hook(human_only)\n@crescent.event\nasync def on_message(event: hikari.MessageCreateEvent):\n    print(\"Received an event from a human.\")\n</code></pre> <p>Similar to command hooks, <code>HookResult</code> can be used to exit early from a function in a event hook. After hooks can also be used.</p>"},{"location":"guides/plugins/","title":"Plugins","text":"<p>Plugins are used to split your bot into multiple files. Plugins require your bot to be packaged, so it is recommended to follow this structure. You can see an example of this structure in the crescent template.</p> <pre><code>working_directory/\n    bot/\n        __main__.py\n        plugins/\n            plugin_a.py\n            plugin_b.py\n</code></pre> <p>The <code>__main__.py</code> file is where you create your client. It would look something like this:</p> <pre><code>import crescent\nimport hikari\n\nbot = hikari.GatewayBot(\"YOUR_TOKEN_HERE\")\nclient = crescent.Client(bot)\n\nbot.run()\n</code></pre> <p>Now to load plugins, simply use the <code>bot.plugins.load_folder</code> function.</p> <pre><code>bot = hikari.GatewayBot(\"YOUR_TOKEN_HERE\")\nclient = crescent.Client(bot)\n\nclient.plugins.load_folder(\"bot.plugins\")\n\nbot.run()\n</code></pre> <p>When you run your bot with <code>python -m bot</code> from <code>working_directory</code>, plugins will be loaded on startup.</p> <p>Note</p> <p>The path that is used to load plugins is relative to the directory  you are running the bot from.</p>"},{"location":"guides/plugins/#inside-a-plugin-file","title":"Inside a plugin file","text":"<p>In the inside of your plugin file you create a plugin class. You can use <code>@plugin.include</code> to add a command to your bot exactly the same way you would with <code>@bot.include</code>. The <code>plugin</code> variable must be called <code>plugin</code>.</p> <pre><code>plugin = crescent.Plugin[hikari.GatewayBot, None]()\n\n@plugin.include\n@crescent.command\nclass plugin_command:\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        await ctx.respond(\"Inside a plugin\")\n</code></pre> <p>If you need to access your bot class inside a plugin file, you can use the <code>plugin.app</code> attribute. Accessing this attribute will raise an exception if the plugin is not yet loaded.</p> <pre><code>plugin = crescent.Plugin[hikari.GatewayBot, None]()\n\n@plugin.include\n@crescent.command\nclass plugin_command:\n    async def callback(self, ctx: crescent.Context) -&gt; None:\n        print(plugin.app)  # &lt;crescent.bot.Bot object at 0x????????????&gt;\n        ...\n</code></pre>"},{"location":"guides/plugins/#hooks","title":"Hooks","text":"<p>Plugins allow you run to run functions when they are loaded and unloaded.</p> <pre><code>plugin = crescent.Plugin[hikari.GatewayBot, None]()\n\n@plugin.load_hook\ndef load():\n    print(\"The plugin is loaded\")\n\n@plugin.unload_hook\ndef unload():\n    print(\"The plugin is unloaded\")\n</code></pre>"},{"location":"guides/plugins/#type-safe-pluginapp","title":"Type Safe <code>plugin.app</code>","text":"<p>If you are using a inherited bot class you can change generics on <code>crescent.Plugin</code> so <code>plugin.app</code> is typed with your class.</p> <pre><code>import typing\n\nclass MyBot(hikari.GatewayBot):\n    ...\n\nMyPlugin = crescent.Plugin[MyBot, None]\n\ntyping.reveal_type(MyPlugin().app)  # `MyBot`\n</code></pre>"},{"location":"guides/plugins/#sharing-state-between-plugins","title":"Sharing State Between Plugins","text":"<p>Sharing objects between different files is hard, Crescent provides the <code>model</code> attribute on plugins to solve this problem. A <code>model</code> is any object you want that will be injected into your plugins.</p> <p>The <code>model</code> does the same role as dependency injection in hikari-arc and hikari-tanjun.</p> <pre><code>import dataclasses\nimport hikari\nimport crescent\n\n\n# The example model is a dataclass. This class can be whatever you want.\n@dataclasses.dataclass\nclass Model:\n    value = 5\n\nbot = hikari.GatewayBot(\"TOKEN\")\nclient = crescent.Client(bot, Model())\n</code></pre> <p>You should also update your plugin type alias to use the model you created.</p> <pre><code>Plugin = crescent.Plugin[hikari.GatewayBot, Model]\n</code></pre> <p>After the plugin is loaded, you can access your model with the <code>model</code> property.</p> <pre><code># The plugin option created in the previous code block.\nplugin = Plugin()\n\n# A function that is run when the plugin is loaded. The antithesis, `plugin.unload_hook`, also exists.\n@plugin.load_hook\ndef on_load():\n    print(plugin.model)\n</code></pre>"},{"location":"guides/plugins/#tips-and-tricks","title":"Tips and Tricks","text":"<ul> <li> <p>Objects That Need to be Created in an Async Function</p> <p>Its common to have objects that need to be instantiated in an async function. The easiest way to do this is subscribing a method on your model to <code>hikari.StartingEvent</code>.</p> <pre><code>class Model:\n    def __init__(self) -&gt; None:\n        self._db: Database | None = None\n\n    async def on_start(self, _: hikari.StartedEvent) -&gt; None:\n        self._db = await Database.create()\n\n    @property\n    def db(self) -&gt; Database:\n        assert self._db\n        return self._db\n\nmodel = Model()\n\nbot = hikari.GatewayBot(\"TOKEN\")\nclient = crescent.Client(bot, model)\n\nbot.event_manager.subscribe(hikari.StartedEvent, model.on_start)\n\nbot.run()\n</code></pre> </li> </ul>"},{"location":"guides/ext/cooldowns/","title":"Cooldowns","text":"<p>This module allows you to rate limit users with a sliding window rate limit.</p> <p>The <code>crescent.ext.cooldowns</code> module provides a hook.</p> <ul> <li><code>capacity</code> is the amount of times the command can be used in a timeframe.</li> <li><code>period</code> is the length of this timeframe.</li> </ul> <pre><code>import crescent\nimport datetime\nfrom crescent.ext import cooldowns\n\n@client.include\n# This command be used 3 times in 20 seconds.\n@crescent.hook(cooldowns.cooldown(capacity=3, period=datetime.timedelta(seconds=20)))\n@crescent.command\nasync def cooldowned(ctx: crescent.Context):\n    print(\"Doing expensive operation...\")\n    await ctx.respond(\"Hello!\")\n</code></pre>"},{"location":"guides/ext/cooldowns/#rate-limited-hook","title":"Rate Limited Hook","text":"<p>Callbacks can be set to run when a user is ratelimited.</p> <pre><code>async def on_rate_limited(ctx: crescent.Context, time_remaining: datetime.timedelta) -&gt; None:\n    await ctx.respond(f\"You are ratelimited for {time_remaining.total_seconds()}s.\")\n\n@client.include\n@crescent.hook(\n    cooldowns.cooldown(1, datetime.timedelta(minutes=1), callback=on_rate_limited),\n)\n@crescent.command\nasync def cooldowned(ctx: crescent.Context) -&gt; None:\n    print(\"Doing expensive operation...\")\n    await ctx.respond(\"Hello!\")\n</code></pre>"},{"location":"guides/ext/cooldowns/#custom-bucket","title":"Custom Bucket","text":"<p>The default bucket uses user IDs to separate users.</p> <p>This is how the default bucket is implemented: <pre><code>import typing\nimport crescent\n\ndef default_bucket(ctx: crescent.Context) -&gt; typing.Any:\n    return ctx.user.id\n</code></pre></p> <p>This is a bucket that rate limits users based on ID and guild ID: <pre><code>import crescent\nimport typing\n\ndef custom_bucket(ctx: crescent.Context) -&gt; typing.Any:\n    return f\"{ctx.guild_id}{ctx.user.id}\"\n</code></pre></p> <p>To use a custom bucket, pass it into the <code>bucket</code> kwarg.</p> <pre><code>@client.include\n@crescent.hook(cooldowns.cooldown(3, datetime.timedelta(seconds=20), bucket=custom_bucket))\n@crescent.command\nasync def cooldowned(ctx: crescent.Context):\n    print(\"Doing expensive operation...\")\n    await ctx.respond(\"Hello!\")\n</code></pre>"},{"location":"guides/ext/locales/","title":"Locales","text":"<p>Locales are used to localize your bot for different regions and languages.</p>"},{"location":"guides/ext/locales/#locale-map","title":"Locale Map","text":"<p>Locale map is a simple way to use locales is <code>LocaleMap</code>.</p> <pre><code>import hikari\nimport crescent\nfrom crescent.ext import locales\n\nbot = hikari.GatewayBot(token=\"YOUR_TOKEN\")\nclient = crescent.Client(bot)\n\nlocale_map = locales.LocaleMap(\"name\", en_US=\"english-name\", en_GB=\"english-name\", fr=\"french-name\")\n\n@client.include\n@crescent.command(\n    name=locale_map,\n    description=locales.LocaleMap(\n        \"description\",\n        en_US=\"english-description\",\n        en_GB=\"english-description\",\n        fr=\"french-description\",\n    ),\n)\nasync def command_2(ctx: crescent.Context) -&gt; None:\n    ...\n</code></pre> <p>The <code>i18n</code> library can also be used for locales with the <code>i18n</code> object. You should check the <code>i18n</code> documentation for more information.</p> <p>Warning</p> <p>You must install the <code>i18n</code> library with <code>hikari-crescent[i18n]</code> to use <code>i18n</code>.</p> <pre><code>import i18n\n\ni18n.add_translation(\"name\", \"english-name\", locale=\"en\")\ni18n.add_translation(\"name\", \"french-name\", locale=\"fr\")\n\ni18n.add_translation(\"description\", \"english-description\", locale=\"en\")\ni18n.add_translation(\"description\", \"french-description\", locale=\"fr\")\n\n\n# This command will have its name and translation in the french and english locales.\n@client.include\n@crescent.command(name=locales.i18n(\"name\"), description=locales.i18n(\"description\"))\nasync def command(ctx: crescent.Context) -&gt; None:\n    ...\n</code></pre>"},{"location":"guides/ext/tasks/","title":"Tasks","text":"<p>This module allows you to loop functions on a certain time period.</p>"},{"location":"guides/ext/tasks/#loops","title":"Loops","text":"<p>Loops run a certain time period after you start the bot.</p> <p>Using kwargs, functions can be set to loop after a certain amount of hours, minutes, or seconds.</p> <pre><code>from crescent.ext import tasks\nfrom datetime import datetime\n\n# This function runs once every minute.\n@client.include\n@tasks.loop(hours=0, minutes=1, seconds=0)\nasync def loop():\n    print(datetime.now())\n</code></pre> <p>A <code>datetime.timedelta</code> object can be passed in to <code>tasks.loop</code> for more control over when the function loops.</p> <pre><code>from crescent.ext import tasks\nfrom datetime import datetime, timedelta\n\n# This function runs once every day.\n@client.include\n@tasks.loop(timedelta(days=1))\nasync def loop():\n    print(datetime.now())\n</code></pre>"},{"location":"guides/ext/tasks/#cronjobs","title":"Cronjobs","text":"<p>Cronjobs are supported with the <code>tasks.cronjob</code> function. crontab.guru is useful for writing cron expressions.</p> <p>Info</p> <p>The library croniter is used for parsing cron expressions.</p> <pre><code>from crescent.ext import tasks\nfrom datetime import datetime\n\n# This function runs once every minute.\n@client.include\n@tasks.cronjob(\"* * * * *\")\nasync def loop():\n    print(datetime.now())\n</code></pre> <p>The <code>on_startup=True</code> can be set to force the function to run when the bot is started.</p> <pre><code>@client.include\n@tasks.cronjob(\"* * * * *\", on_startup=True)\nasync def loop():\n    print(datetime.now())\n</code></pre>"}]}